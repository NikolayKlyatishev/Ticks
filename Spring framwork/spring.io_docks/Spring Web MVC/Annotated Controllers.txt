Annotated Controllers - аннотирование контроллеров.

	Spring MVC предоставляет модель программирования на основе аннотаций, в которой компоненты @Controller и @RestController используют аннотации для выражения маппинга запросов, ввода запросов, обработки исключений и т. д. Аннотированные контроллеры имеют гибкие сигнатуры методов и не должны расширять базовые классы или реализовывать определенные интерфейсы. В следующем примере показан контроллер, определенный аннотациями:

			@Controller
			public class HelloController {

				@GetMapping("/hello")
				public String handle(Model model) {
					model.addAttribute("message", "Hello World!");
					return "index";
				}
			}
			
	В предыдущем примере метод принимает Model и возвращает имя представления в виде строки.	
	
DECLARATION - объявление контроллера
	
	Вы можете определить бины контроллера с помощью стандартного определения Spring bean в Webapplicationcontext сервлета. Аннотация @Controller позволяет автоматически обнаруживать, так же как классы, помеченные аннотацией @Component и автоматической регистрации бинов для них. Он также действует как аннотация для аннотированного класса, указывая на его роль в качестве веб-компонента.
	
	Чтобы включить автоматическое обнаружение бинов @Controller, можно добавить сканирование компонентов в конфигурацию Java, как показано в следующем примере:
	
	@Configuration
	@ComponentScan("org.example.web")
	public class WebConfig {

		// ...
	}
	
	В следующем примере показан эквивалент конфигурации XML из предыдущего примера:
	
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:component-scan base-package="org.example.web"/>

		<!-- ... -->
	</beans>
	
	@RestController-это составная аннотация, которая сама по себе состоит из @Controller и @ResponseBody, и указывает на контроллер, каждый метод которого наследует аннотацию типа @ResponseBody и, следовательно, записывает непосредственно в тело ответа в зависимости от view resolution и отображается с помощью шаблона HTML.
	
AOP Proxies
	
	В некоторых случаях может потребоваться декорировать контроллер прокси-сервером AOP во время выполнения. Примером может быть ситуация, в которой вы решили использовать @Transactional аннотации непосредственно в контроллере. В этом случае, для контроллеров рекомендуется использовать проксирование на основе классов. Это, как правило, выбор по умолчанию с контроллерами. Однако если контроллер должен реализовать интерфейс, который не является обратным вызовом контекста Spring (например, InitializingBean, *Aware и другие), вам может потребоваться явно настроить проксирование на основе классов. Например, с <tx:annotation-driven/> можно заменить на <tx:annotation-driven proxy-target-class="true"/>.
	

REQUEST MAPPING - привязка запросов.
	
	Вы можете использовать аннотацию @RequestMapping для сопоставления запросов к методам контроллеров. Он использует различные атрибуты, для соответствия URL-адреса, HTTP-метода, параметры запроса, заголовки и типы носителей. Его можно использовать на уровне класса для выражения общих сопоставлений или на уровне метода для сужения до определенного сопоставления конечных точек.
	
	Существуют определенные аннотации для детализации аннотации @RequestMapping HTTP-запроса по типам запросов:
	
	@GetMapping
	@PostMapping
	@PutMapping
	@DeleteMapping
	@PatchMapping
	
	Детализация аннотаций важна, поскольку большинство методов контроллера должны быть сопоставлены с определенными методами HTTP (GET, POST, PUT, DELETE, PATCH). Все они по умолчанию являются HTTP методами и могут быть обработаны аннотацией @RequestMapping, но детализация достигается за счет использования детализированных аннотаций, перечисленных выше.
	
	Пример, приведенный ниже демонстрирует детализацию обработки запроса по уровню привязки методов:
	
	@RestController
	@RequestMapping("/persons")
	class PersonController {

		@GetMapping("/{id}")
		public Person getPerson(@PathVariable Long id) {
			// ...
		}

		@PostMapping
		@ResponseStatus(HttpStatus.CREATED)
		public void add(@RequestBody Person person) {
			// ...
		}
	}
	

URI patterns - шаблоны URI
	
	Запросы можно сопоставлять с помощью следующих глобальных шаблонов и подстановочных знаков:
	
	?  - соответствует одному символу
	*  - соответствует нулю или более символов в сегменте пути
	** - сопоставьте ноль или более сегментов пути
	
	Вы можете объявить переменные URI и получить доступ к их значениям с помощью @PathVariable, как показано в следующем примере:
	
	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
		// ...
	}
	
	Переменные URI можно объявлять на уровне класса и метода, как показано в следующем примере:
	
	@Controller
	@RequestMapping("/owners/{ownerId}")
	public class OwnerController {

		@GetMapping("/pets/{petId}")
		public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
			// ...
		}
	}
	
	Переменные URI автоматически преобразуются в соответствующий тип или создается исключение TypeMismatchException. Простые типы (int, long, Date и т. д.) поддерживаются по умолчанию, и вы можете зарегистрировать поддержку для любого другого типа данных.
	Вы можете явно указать переменные URI (например, @PathVariable ("customId")), или не объявлять, если имена совпадают, и ваш код скомпилирован с отладочной информацией или с флагом компилятора-parameters на Java 8
	
	Синтаксис {varName:regex} - может быть объявлена переменная URI с регулярным выражением. Например, если задан URL "/spring-web-3.0.5.jar", тогда метод извлекает имя, версию и расширение:
	
	
	@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
	public void handle(@PathVariable String version, @PathVariable String ext) {
		// ...
	}
	
	Шаблоны путей URI могут иметь встроенные параметры ${...}, которые устанавливаются при запуске с помощью PropertyPlaceHolderConfigurer для локальных, системных, средовых и других источников свойств. Это используется, например, для параметризации базового URL-адреса на основе некоторой внешней конфигурации.
	
	
Pattern Comparison - Сравнение шаблонов.
	
	Когда несколько шаблонов соответствуют URL-адресу, их необходимо сравнить, чтобы найти более подходящий шаблон. Это делается с помощью AntPathMatcher.getPatternComparator(string path), который ищет более подходящие модели.
	
	При равном счете выбирается шаблон, имеющий большее количество переменных URI ${...}.
	
	Шаблон сопоставления по умолчанию (/**) исключается из оценки и всегда сортируется последним. Кроме того, шаблоны префиксов (такие как /public/**) считаются менее специфичными, чем другие шаблоны, которые не имеют двойных подстановочных знаков.
	
	Для получения полной информации см. AntPatternComparator в AntPathMatcher, а также имейте в виду, что вы можете настроить реализацию PathMatcher. 
	См. https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-config-path-matching
	
	
SUFFIX MATCH

	По умолчанию Spring MVC выполняет (.*) шаблон суффикс совпадающих так, что контроллер привязан к ("/person") тоже неявно привязак к ("/person.*"). Расширение файла затем используется для интерпретации запрошенного типа контента для использования в ответе (то есть вместо заголовка Accept) — например, /person.pdf, /person.XML и другие.
	
	Чтобы полностью отключить использование расширений файлов, необходимо установить оба следующих параметра:
	
	useSuffixPatternMatching(false), see PathMatchConfigurer
	favorPathExtension(false), see ContentNegotiationConfigurer
	
	В Spring MVC методы @ResponseBody и @ResponseEntity находятся под угрозой, поскольку они могут отображать различные типы контента, которые клиенты могут запрашивать через расширения пути URL. Отключение сопоставления шаблонов суффиксов и использование расширений путей для согласования содержимого снижает риск, но не является достаточным для предотвращения атак RFD.
	
	Чтобы предотвратить атаки RFD, перед рендерингом тела ответа Spring MVC добавляет Content-Disposition: inline;filename=f.txt заголовок, чтобы предложить фиксированный и безопасный файл загрузки. Это делается только в том случае, если URL-адрес содержит расширение файла, которое не является ни белым списком, ни явно зарегистрированным для согласования содержимого. Однако он потенциально может иметь побочные эффекты, когда URL-адреса вводятся непосредственно в браузер.
	
	Многие распространенные расширения пути по умолчанию занесены в белый список. Приложения с пользовательскими реализациями HttpMessageConverter могут явно регистрировать расширения файлов для согласования содержимого, чтобы избежать добавления заголовка Content-Disposition для этих расширений. См. Раздел Типы Контента.
	
	См. CVE-2015-5211 для получения дополнительных рекомендаций, связанных с RFD.
	
	Можно сузить сопоставление запроса на основе типа содержимого запроса, как показано в следующем примере:

	Использование атрибута consumes для сужения сопоставления по типу контента:

	@PostMapping(path = "/pets", consumes = "application/json") 
	public void addPet(@RequestBody Pet pet) {
		// ...
	}	
	
	Атрибут consumes также поддерживает выражения отрицания — например,!text/plain означает любой тип контента, отличный от text/plain
	
	Вы можете объявить общий артибут на уровне классов. Однако, в отличие от большинства других атрибутов сопоставления запросов, при использовании на уровне класса метод использует переопределения атрибутов, а не расширяет объявление уровня класса.
	
	MediaType предоставляет константы для часто используемых типов носителей, таких как APPLICATION_JSON_VALUE и APPLICATION_XML_VALUE.