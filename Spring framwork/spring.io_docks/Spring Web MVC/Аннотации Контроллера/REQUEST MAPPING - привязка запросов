REQUEST MAPPING - привязка запросов.
	
	Вы можете использовать аннотацию @RequestMapping для сопоставления запросов к методам контроллеров. Он использует различные атрибуты, для соответствия URL-адреса, HTTP-метода, параметры запроса, заголовки и типы носителей. Его можно использовать на уровне класса для выражения общих сопоставлений или на уровне метода для сужения до определенного сопоставления конечных точек.
	
	Существуют определенные аннотации для детализации аннотации @RequestMapping HTTP-запроса по типам запросов:
	
	@GetMapping
	@PostMapping
	@PutMapping
	@DeleteMapping
	@PatchMapping
	
	Детализация аннотаций важна, поскольку большинство методов контроллера должны быть сопоставлены с определенными методами HTTP (GET, POST, PUT, DELETE, PATCH). Все они по умолчанию являются HTTP методами и могут быть обработаны аннотацией @RequestMapping, но детализация достигается за счет использования детализированных аннотаций, перечисленных выше.
	
	Пример, приведенный ниже демонстрирует детализацию обработки запроса по уровню привязки методов:
	
	@RestController
	@RequestMapping("/persons")
	class PersonController {

		@GetMapping("/{id}")
		public Person getPerson(@PathVariable Long id) {
			// ...
		}

		@PostMapping
		@ResponseStatus(HttpStatus.CREATED)
		public void add(@RequestBody Person person) {
			// ...
		}
	}
	

URI patterns - шаблоны URI
	
	Запросы можно сопоставлять с помощью следующих глобальных шаблонов и подстановочных знаков:
	
	?  - соответствует одному символу
	*  - соответствует нулю или более символов в сегменте пути
	** - сопоставьте ноль или более сегментов пути
	
	Вы можете объявить переменные URI и получить доступ к их значениям с помощью @PathVariable, как показано в следующем примере:
	
	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
		// ...
	}
	
	Переменные URI можно объявлять на уровне класса и метода, как показано в следующем примере:
	
	@Controller
	@RequestMapping("/owners/{ownerId}")
	public class OwnerController {

		@GetMapping("/pets/{petId}")
		public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
			// ...
		}
	}
	
	Переменные URI автоматически преобразуются в соответствующий тип или создается исключение TypeMismatchException. Простые типы (int, long, Date и т. д.) поддерживаются по умолчанию, и вы можете зарегистрировать поддержку для любого другого типа данных.
	Вы можете явно указать переменные URI (например, @PathVariable ("customId")), или не объявлять, если имена совпадают, и ваш код скомпилирован с отладочной информацией или с флагом компилятора-parameters на Java 8
	
	Синтаксис {varName:regex} - может быть объявлена переменная URI с регулярным выражением. Например, если задан URL "/spring-web-3.0.5.jar", тогда метод извлекает имя, версию и расширение:
	
	
	@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
	public void handle(@PathVariable String version, @PathVariable String ext) {
		// ...
	}
	
	Шаблоны путей URI могут иметь встроенные параметры ${...}, которые устанавливаются при запуске с помощью PropertyPlaceHolderConfigurer для локальных, системных, средовых и других источников свойств. Это используется, например, для параметризации базового URL-адреса на основе некоторой внешней конфигурации.
	
	
Pattern Comparison - Сравнение шаблонов.
	
	Когда несколько шаблонов соответствуют URL-адресу, их необходимо сравнить, чтобы найти более подходящий шаблон. Это делается с помощью AntPathMatcher.getPatternComparator(string path), который ищет более подходящие модели.
	
	При равном счете выбирается шаблон, имеющий большее количество переменных URI ${...}.
	
	Шаблон сопоставления по умолчанию (/**) исключается из оценки и всегда сортируется последним. Кроме того, шаблоны префиксов (такие как /public/**) считаются менее специфичными, чем другие шаблоны, которые не имеют двойных подстановочных знаков.
	
	Для получения полной информации см. AntPatternComparator в AntPathMatcher, а также имейте в виду, что вы можете настроить реализацию PathMatcher. 
	См. https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-config-path-matching
	
	
SUFFIX MATCH - суффикс

	По умолчанию Spring MVC использует шаблон с суффиксом (.*), поэтому контроллер привязаный к ("/person") неявно привязан и к ("/person.*"). Затем, расширение файла используется для интерпретации типа содержимого для использования в ответе (то есть вместо заголовка Accept) — например, /person.pdf, /person.XML и другие.
	
	Чтобы полностью отключить использование расширений файлов, необходимо установить оба следующих параметра:
	
	useSuffixPatternMatching(false), see PathMatchConfigurer
	favorPathExtension(false), see ContentNegotiationConfigurer
	
	В Spring MVC методы @ResponseBody и @ResponseEntity находятся под угрозой, поскольку они могут отображать различные типы контента, которые клиенты могут запрашивать через расширения пути URL. Отключение сопоставления шаблонов суффиксов и использование расширений путей для согласования содержимого снижает риск, но не является достаточным для предотвращения атак RFD.
	
	Чтобы предотвратить атаки RFD, перед рендерингом тела ответа Spring MVC добавляет Content-Disposition: inline;filename=f.txt заголовок, чтобы предложить фиксированный и безопасный файл загрузки. Это делается только в том случае, если URL-адрес содержит расширение файла, которое не является ни белым списком, ни явно зарегистрированным для согласования содержимого. Однако он потенциально может иметь побочные эффекты, когда URL-адреса вводятся непосредственно в браузер.
	
	Многие распространенные расширения пути по умолчанию занесены в белый список. Приложения с пользовательскими реализациями HttpMessageConverter могут явно регистрировать расширения файлов для согласования содержимого, чтобы избежать добавления заголовка Content-Disposition для этих расширений. См. Раздел Типы Контента.
	
	См. CVE-2015-5211 для получения дополнительных рекомендаций, связанных с RFD.
	
	Можно сузить сопоставление запроса на основе типа содержимого запроса, как показано в следующем примере:

	Использование атрибута consumes для сужения сопоставления по типу контента:

	@PostMapping(path = "/pets", consumes = "application/json") 
	public void addPet(@RequestBody Pet pet) {
		// ...
	}	
	
	Атрибут consumes также поддерживает выражения отрицания — например,!text/plain означает любой тип контента, отличный от text/plain
	
	Вы можете объявить общий артибут на уровне классов. Однако, в отличие от большинства других атрибутов сопоставления запросов, при использовании на уровне класса метод использует переопределения атрибутов, а не расширяет объявление уровня класса.
	
	MediaType предоставляет константы для часто используемых типов носителей, таких как APPLICATION_JSON_VALUE и APPLICATION_XML_VALUE.


Producible Media Types - Воспроизводимые Типы Носителей

	Сопоставление запросов можно сузить на основе заголовка запроса Accept и списка типов контента, создаваемых методом контроллера, как показано в следующем примере:

		@GetMapping(path = "/pets/{petId}", produces = "application/json;charset=UTF-8") 
		@ResponseBody
		public Pet getPet(@PathVariable String petId) {
		    // ...
		}

	Использование атрибута produces для сужения сопоставления по типу контента.

	Тип носителя может указывать набор символов. Отрицательные выражения поддерживаются — например,!text/plain означает любой тип контента, отличный от "text / plain".


Parameters, headers - Параметры. заголовки.
	
	Вы можете сузить привязку запроса основываясь на условия по параметрам запроса.
	Вы можете проверить присутствие параметра в запросе (myParam), отсутствие параметра в запросе (!myParam), конкретное значение параметра (myParam=myValue).

	Следующий пример демонстрирует как можно проверить значение параметра:

	params проверяет равенство параметра с именем myParam значению myValue:
	
	@GetMapping(path = "/pets/{petId}", params = "myParam=myValue") 
	public void findPet(@PathVariable String petId) {
	    // ...
	}

	Таким же образом можно проверить заголовок:

	headers проверят значение заколовка
	@GetMapping(path = "/pets", headers = "myHeader=myValue") 
	public void findPet(@PathVariable String petId) {
	    // ...
	}


HTTP HEAD, OPTIONS - заголовок HTTP, опции
	
	@GetMapping (и @RequestMapping(method=HttpMethod.GET)) достаточно тривиально поддерживают привязку HTTP HEAD. Методы контроллера не нужно менять. Обертка ответа, применяемая в javax.servlet.http.HttpServlet, гарантирует, что заголовок Content-Length равен количеству записанных байт.

	@GetMapping (and @RequestMapping(method=HttpMethod.GET)) неявно привязан и поддерживает HTTP HEAD. Запрос HTTP HEAD обрабатывается так, как если бы это был HTTP GET, за исключением того, что вместо записи тела подсчитывается количество байтов и устанавливается заголовок Content-Length.

	По умолчанию параметры HTTP обрабатываются путем установки заголовка разрешающих ответ на список методов HTTP, перечисленных во всех методах @RequestMapping, которые имеют соответствующие шаблоны URL.

	Для @RequestMapping без объявления метода HTTP заголовок Allow имеет значение GET,HEAD,POST,PUT,PATCH,DELETE, OPTIONS. Методы контроллера всегда должны объявлять поддерживаемые методы HTTP (например, с помощью определенных вариантов метода HTTP: @GetMapping, @PostMapping и других).

	Вы можете явно сопоставить метод @RequestMapping с параметрами HTTP HEAD и HTTP, но в общем случае это необязательно.


CUSTOM ANNOTATION - Пользовательские Аннотации
	
	Spring MVC поддерживает использование составленных аннотаций для сопоставления запросов. Это аннотации, которые сами являются мета-аннотированными с помощью @RequestMapping и составлены для повторного объявления подмножества (или всех) атрибутов @RequestMapping с более узкой, более конкретной целью.
	@GetMapping, @PostMapping, @PutMapping, @DeleteMapping и @PatchMapping являются примерами пользовательских аннотаций. Они предоставляются потому, что, возможно, большинство методов контроллера должны быть сопоставлены с определенным методом HTTP по сравнению с использованием @RequestMapping, который по умолчанию соответствует всем методам HTTP. Если вам нужен пример пользовательских аннотаций, посмотрите, как они объявляются.

	Spring MVC также поддерживает пользовательские атрибуты сопоставления запросов с пользовательской логикой сопоставления запросов. Это более продвинутый вариант, который требует подкласса RequestMappingHandlerMapping и переопределения метода getCustomMethodCondition, где можно проверить пользовательский атрибут и вернуть свой собственный RequestCondition.


Explicit Registrations - явная регистрация

	Вы можете программно зарегистрировать методы обработчика, и использовать их для динамических регистраций или подобных случаев, таких как различные экземпляры одного и того же обработчика по разным URL-адресам. 

	В следующем примере регистрируется метод обработчика:

	@Configuration
	public class MyConfig {

		// Инжектим RequestMappingHandlerMapping и UserHandler
		@Autowired
		public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) 
		        throws NoSuchMethodException {

		    // Подготовка метаданных сопоставления запросов
		    RequestMappingInfo info = RequestMappingInfo.paths("/user/{id}").methods(RequestMethod.GET).build(); 

		    // Получаем метод обработчика
		    Method method = UserHandler.class.getMethod("getUser", Long.class); 

		   	// Добавляем регистрацию
		    mapping.registerMapping(info, handler, method); 
			}
	}
