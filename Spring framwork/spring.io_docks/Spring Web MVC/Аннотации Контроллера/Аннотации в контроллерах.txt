Аннотации



@RequestParam - используется для привязки параметров запроса сервлета (то есть параметров запроса или данных формы) к аргументу метода в контроллере.
			
		Используйте @RequestParam для связки параметра метода petId с параметром запроса petId
	
		@Controller
		@RequestMapping("/pets")
		public class EditPetForm {

			// ...
			@GetMapping
			public String setupForm(@RequestParam("petId") int petId, Model model) { 
				Pet pet = this.clinic.loadPet(petId);
				model.addAttribute("pet", pet);
				return "petForm";
			}
			// ...
		}
	
	По умолчанию параметры метода, использующие эту аннотацию, являются обязательными, но вы можете указать, что параметр метода является необязательным, установив обязательный флаг аннотации @RequestParam в false или объявив аргумент с помощью обертки java.util.Optional
	Преобразование типов применяется автоматически, если тип параметра целевого метода не является строковым. См. Раздел Преобразование Типов.
	Когда аннотация @RequestParam объявляется как Map<String, String> или MultiValueMap<String, String>, без имени параметра, указанного в аннотации, то карта заполняется значениями параметров запроса для каждого заданного имени параметра.
	Обратите внимание, что использование @RequestParam является необязательным (например, для установки его атрибутов). По умолчанию любой аргумент, который является простым типом значения (как определено BeanUtils#isSimpleProperty) и не разрешен никаким другим преобразователем аргументов, обрабатывается так, как если бы он был аннотирован с помощью @RequestParam.
	
	
	
@RequestHeader - используется для привязки заголовка запроса к аргументу метода в контроллере.

	Рассмотрим следующий запрос, с заголовками:
	
		Host                    localhost:8080
		Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
		Accept-Language         fr,en-gb;q=0.7,en;q=0.3
		Accept-Encoding         gzip,deflate
		Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
		Keep-Alive              300
	
	В следующем примере возвращается значение заголовков Accept-Encoding и Keep-Alive:
	
		// Получение значение заголовка Accept-Encoding
		// Получение значение заголовка Keep-Alive.
		
		@GetMapping("/demo")
		public void handle(
				@RequestHeader("Accept-Encoding") String encoding, 
				@RequestHeader("Keep-Alive") long keepAlive) { 
			//...
		}
		
	Если тип параметра в методе не String - автоматически применяется преобразование типов, описанное в разделе Type Conversion.	

	Если аннотация @RequestHeader используется для аргумента с типами Map<String, String>, MultiValueMap<String, String> или HttpHeaders, Map заполняется всеми значениями заголовка.
	
	Встроенная поддержка доступна для преобразования строки, разделенной запятыми, в массив или коллекцию строк или других типов, известных системе преобразования типов. Например, параметр метода с аннотацией @RequestHeader ("Accept") может иметь тип String, но также String[] или List<String>.
	
	
	
@CookieValue - используется аннотация @CookieValue для привязки значения http cookie к аргументу метода в контроллере.

	Рассмотрим запрос со следующим файлом cookie:
		
		JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84
		
	В следующем примере показано, как получить значение cookie:
	
		@GetMapping("/demo")
		public void handle(@CookieValue("JSESSIONID") String cookie) { 
			//...
		}	

		Получить значение файла cookie JSESSIONID.

	Если тип параметра в методе не String - автоматически применяется преобразование типов, описанное в разделе Type Conversion.	
	


@ModelAttribute - используется аннотация @ModelAttribute для аргумента метода, для получения доступа к атрибуту из модели или создать его экземпляр, если он отсутствует. Атрибут модели накладывается на значения из параметров запроса сервлета HTTP, по совпадению имен полей. Это называется маппингом данных, и это избавляет вас от необходимости ручного разбора и преобразования отдельных параметров запроса и полей формы. В следующем примере показано, как это сделать:	

		@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
		public String processSubmit(@ModelAttribute Pet pet) { 
			// ...
		} 
		
		Привязать экземпляр Pet

	Экземпляр Pet получается следующим образом:

	- Из модели, если она уже добавлена с помощью Model.
	- Из сеанса HTTP с помощью @SessionAttributes.
	- Из переменной URI path, переданной через Converter (см. Следующий пример).
	- Из вызова конструктора по умолчанию.
	- Из вызова "первичного конструктора" с аргументами, которые соответствуют параметрам запроса сервлета. Имена аргументов определяются с помощью JavaBeans @ConstructorProperties или с помощью сохраняемых во время выполнения имен параметров в байт-коде.

	Хотя для заполнения модели атрибутами обычно используется Model, другой альтернативой является использование Converter<String, T> в сочетании с соглашением о переменной пути URI. В следующем примере имя атрибута модели account соответствует переменной URI path account, и учетная запись загружается путем передачи номера учетной записи String через зарегистрированный Converter<String, Account>:
	
		@PutMapping("/accounts/{account}")
		public String save(@ModelAttribute("account") Account account) {
			// ...
		}

