Аннотации



@RequestParam - используется для привязки параметров запроса сервлета (то есть параметров запроса или данных формы) к аргументу метода в контроллере.
			
		Используйте @RequestParam для связки параметра метода petId с параметром запроса petId
	
		@Controller
		@RequestMapping("/pets")
		public class EditPetForm {

			// ...
			@GetMapping
			public String setupForm(@RequestParam("petId") int petId, Model model) { 
				Pet pet = this.clinic.loadPet(petId);
				model.addAttribute("pet", pet);
				return "petForm";
			}
			// ...
		}
	
	По умолчанию параметры метода, использующие эту аннотацию, являются обязательными, но вы можете указать, что параметр метода является необязательным, установив обязательный флаг аннотации @RequestParam в false или объявив аргумент с помощью обертки java.util.Optional
	Преобразование типов применяется автоматически, если тип параметра целевого метода не является строковым. См. Раздел Преобразование Типов.
	Когда аннотация @RequestParam объявляется как Map<String, String> или MultiValueMap<String, String>, без имени параметра, указанного в аннотации, то карта заполняется значениями параметров запроса для каждого заданного имени параметра.
	Обратите внимание, что использование @RequestParam является необязательным (например, для установки его атрибутов). По умолчанию любой аргумент, который является простым типом значения (как определено BeanUtils#isSimpleProperty) и не разрешен никаким другим преобразователем аргументов, обрабатывается так, как если бы он был аннотирован с помощью @RequestParam.
	
	
	
@RequestHeader - используется для привязки заголовка запроса к аргументу метода в контроллере.

	Рассмотрим следующий запрос, с заголовками:
	
		Host                    localhost:8080
		Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
		Accept-Language         fr,en-gb;q=0.7,en;q=0.3
		Accept-Encoding         gzip,deflate
		Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
		Keep-Alive              300
	
	В следующем примере возвращается значение заголовков Accept-Encoding и Keep-Alive:
	
		// Получение значение заголовка Accept-Encoding
		// Получение значение заголовка Keep-Alive.
		
		@GetMapping("/demo")
		public void handle(
				@RequestHeader("Accept-Encoding") String encoding, 
				@RequestHeader("Keep-Alive") long keepAlive) { 
			//...
		}
		
	Если тип параметра в методе не String - автоматически применяется преобразование типов, описанное в разделе Type Conversion.	

	Если аннотация @RequestHeader используется для аргумента с типами Map<String, String>, MultiValueMap<String, String> или HttpHeaders, Map заполняется всеми значениями заголовка.
	
	Встроенная поддержка доступна для преобразования строки, разделенной запятыми, в массив или коллекцию строк или других типов, известных системе преобразования типов. Например, параметр метода с аннотацией @RequestHeader ("Accept") может иметь тип String, но также String[] или List<String>.
	
	
	
@CookieValue - используется аннотация @CookieValue для привязки значения http cookie к аргументу метода в контроллере.

	Рассмотрим запрос со следующим файлом cookie:
		
		JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84
		
	В следующем примере показано, как получить значение cookie:
	
		@GetMapping("/demo")
		public void handle(@CookieValue("JSESSIONID") String cookie) { 
			//...
		}	

		Получить значение файла cookie JSESSIONID.

	Если тип параметра в методе не String - автоматически применяется преобразование типов, описанное в разделе Type Conversion.	
	


@ModelAttribute - используется аннотация @ModelAttribute для аргумента метода, для получения доступа к атрибуту из модели или создать его экземпляр, если он отсутствует. Атрибут модели накладывается на значения из параметров запроса сервлета HTTP, по совпадению имен полей. Это называется маппингом данных, и это избавляет вас от необходимости ручного разбора и преобразования отдельных параметров запроса и полей формы. В следующем примере показано, как это сделать:	

		@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
		public String processSubmit(@ModelAttribute Pet pet) { 
			// ...
		} 
		
		Привязать экземпляр Pet

	Экземпляр Pet получается следующим образом:

	- Из модели, если она уже добавлена с помощью Model.
	- Из сеанса HTTP с помощью @SessionAttributes.
	- Из переменной URI path, переданной через Converter (см. Следующий пример).
	- Из вызова конструктора по умолчанию.
	- Из вызова "первичного конструктора" с аргументами, которые соответствуют параметрам запроса сервлета. Имена аргументов определяются с помощью JavaBeans @ConstructorProperties или с помощью сохраняемых во время выполнения имен параметров в байт-коде.

	Хотя для заполнения модели атрибутами обычно используется Model, другой альтернативой является использование Converter<String, T> в сочетании с соглашением о переменной пути URI. В следующем примере имя атрибута модели account соответствует переменной URI path account, и учетная запись загружается путем передачи номера учетной записи String через зарегистрированный Converter<String, Account>:
	
		@PutMapping("/accounts/{account}")
		public String save(@ModelAttribute("account") Account account) {
			// ...
		}

	После получения экземпляра атрибута модели применяется привязка данных. Класс WebDataBinder сопоставляет имена параметров запроса сервлета (параметры запроса и поля формы) с именами полей целевого объекта. Соответствующие поля заполняются после применения преобразования типа, где это необходимо. Дополнительные сведения о привязке данных (и проверке) см. В разделе Validation. Дополнительные сведения о настройке привязки данных см. В разделе DataBinder.
	
	Привязка данных может привести к ошибкам. По умолчанию создается исключение BindException. Однако для проверки таких ошибок в методе контроллера можно добавить аргумент BindingResult непосредственно рядом с атрибутом @ModelAttribute, как показано в следующем примере:
	
		@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
		public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result) { 
			if (result.hasErrors()) {
				return "petForm";
			}
			// ...
		}
		
	В некоторых случаях может потребоваться доступ к атрибуту модели без привязки данных. В таких случаях можно ввести модель в контроллер и получить к ней прямой доступ или, в качестве альтернативы, установить @ModelAttribute (binding=false), как показано в следующем примере:
	
		@ModelAttribute
		public AccountForm setUpForm() {
			return new AccountForm();
		}

		@ModelAttribute
		public Account findAccount(@PathVariable String accountId) {
			return accountRepository.findOne(accountId);
		}

		@PostMapping("update")
		public String update(@Valid AccountForm form, BindingResult result,
				@ModelAttribute(binding=false) Account account) { 
			// ...
		}
	
	Вы можете автоматически применить проверку после привязки данных, добавив javax.validation.Valid аннотацию или Спринговую аннотацию @Validated (Bean Validation and Spring validation). В следующем примере показано, как это сделать:
	
		@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
		public String processSubmit(@Valid @ModelAttribute("pet") Pet pet, BindingResult result) { 
			if (result.hasErrors()) {
				return "petForm";
			}
			// ...
		}
	
	Обратите внимание, что использование @ModelAttribute является необязательным (например, для установки его атрибутов). По умолчанию любой аргумент, который не является простым типом значения (как определено BeanUtils#isSimpleProperty) и не разрешен никаким другим преобразователем аргументов, обрабатывается так, как если бы он был аннотирован с помощью @ModelAttribute.
	
	
	
@SessionAttributes - аннотация, которая используется для хранения атрибутов модели в сеансе сервлета HTTP между запросами. Это аннотация уровня класса, которая объявляет атрибуты сеанса, используемые определенным контроллером. Обычно здесь перечислены имена атрибутов модели или типы атрибутов модели, которые должны быть сохранены в сеансе для последующих запросов на доступ.

		@Controller
		@SessionAttributes("pet") 
		public class EditPetForm {
			// ...
		}
	
	При первом запросе, когда атрибут модели с именем pet добавляется к модели, он автоматически повышается и сохраняется в сеансе сервлета HTTP. Он остается там до тех пор, пока другой метод контроллера не использует аргумент метода SessionStatus для очистки хранилища, как показано в следующем примере:
	
		@Controller
		@SessionAttributes("pet") 	// Сохранение значения Pet в сеансе сервлета
		public class EditPetForm {

			// ...

			@PostMapping("/pets/{id}")
			public String handle(Pet pet, BindingResult errors, SessionStatus status) {
				if (errors.hasErrors) {
					// ...
				}
					status.setComplete(); 	// Очистка значения Pet из сеанса сервлета
					// ...
				}
			}
		}
		
		

@SessionAttribute - используется, если вам нужен доступ к уже существующим атрибутам сеанса, которые управляются глобально (то есть вне контроллера — например, с помощью фильтра) и могут присутствовать или нет, как показано в следующем примере:

		@RequestMapping("/")
		public String handle(@SessionAttribute User user) { 
			// ...
		}
		
	Для случаев, требующих добавления или удаления атрибутов сеанса, рассмотрите возможность DI org.springframework.web.context.request.WebRequest или javax.servlet.http.HttpSession в метод контроллера.
		
	Для временного хранения атрибутов модели в сеансе как части рабочего процесса контроллера рекомендуется использовать @ SessionAttributes, как описано в разделе @SessionAttributes.
	

@RequestAttribute - Аналогично @SessionAttribute, вы можете использовать аннотации @RequestAttribute для доступа к уже существующим атрибутам запроса, созданным ранее (например, с помощью фильтра сервлетов или HandlerInterceptor).

		@GetMapping("/")
		public String handle(@RequestAttribute Client client) { 
			// ...
		}