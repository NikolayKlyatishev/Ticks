Handler Methods - методы контроллера.

	Методы контроллера, аннотированные @RequestMapping имеют гибкую сигнатуру и позволяют указать большое количество поддерживаемых аргументов метода контроллера и возвращаемых значений.

METHOD ARGUMENTS - аргументы методов контроллера
	
	В следующей таблице описаны поддерживаемые аргументы метода контроллера. Реактивные типы не поддерживаются ни для каких аргументов.
	Java JDK 8  java.util.Optional поддерживается в качестве аргумента метода в сочетании с аннотациями, которые имеют обязательный атрибут (например, @RequestParam, @RequestHeader и другие) и эквивалентны required=false.

	1. WebRequest, NativeWebRequest - Общий доступ к параметрам запроса и атрибутам запроса и сеанса без прямого использования API сервлета.
	
	2. javax.servlet.ServletRequest, javax.servlet.ServletResponse - Выберите любой конкретный тип запроса или ответа, например ServletRequest, HttpServletRequest или Spring's MultipartRequest, MultipartHttpServletRequest
	
	3. javax.servlet.http.HttpSession - Обеспечивает принудительное присутствие сеанса. Как следствие, такой аргумент никогда не является нулевым. Обратите внимание, что доступ к сеансу не является потокобезопасным. Рассмотрите возможность установки флага synchronizeOnSession экземпляра RequestMappingHandlerAdapter в true, если нескольким запросам разрешено одновременно обращаться к сеансу.
	
	4. javax.servlet.http.PushBuilder - Сервлет 4.0 предоставляет API-интерфейс строителя для программного протокола HTTP/2, ресурс нажатий. Обратите внимание, что в соответствии со спецификацией сервлета введенный экземпляр PushBuilder может иметь значение null, если клиент не поддерживает функцию HTTP/2.
	
	5. java.security.Principal - В настоящее время аутентифицированный пользователь — возможно, определенный основной класс реализации, если он известен.
	
	6. HttpMethod - HTTP-метод запроса.
	
	7. java.util.Locale - Текущая локализация запроса, определяемая наиболее конкретным доступным LocaleResolver (по сути, настроенным LocaleResolver или LocaleContextResolver).
	
	8. java.util.TimeZone + java.time.ZoneId - Часовой пояс, связанный с текущим запросом, определяющийся LocaleContextResolver.
	
	9. java.io.InputStream, java.io.Readerjava.io.InputStream, java.io.Reader - обеспечивает доступ к необработанному телу запроса, предоставляемому Servlet API.
	
	10. java.io.OutputStream, java.io.Writer - Для доступа к необработанному телу ответа, предоставленному API сервлета.
	
	11. @PathVariable - используется для доступа в переменным URI. Позволяет просматривать шаблоны URI.
	
	12. @MatrixVariable - используется для доступа к парам ключ-значение в сегментах пути URI.
	
	13. @RequestParam - Для доступа к параметрам запроса сервлета, включая составные файлы. Значения параметров преобразуются в тип аргумента объявленного метода. См. @RequestParam, а также Multipart. Обратите внимание, что использование @RequestParam является необязательным для простых значений параметров. См. другие аргументы, в конце этой таблицы.
	
	14. @RequestHeader - Для доступа к заголовкам запросов. Значения заголовка преобразуются в тип аргумента объявленного метода. См. Раздел @RequestHeader.
	
	15. @CookieValue - Для доступа к cookies. Значения Cookies преобразуются в тип аргумента объявленного метода. Смотрите @CookieValue.
	
	16. @RequestBody - Для доступа к телу HTTP-запроса. Содержимое тела преобразуется в тип аргумента объявленного метода с помощью реализаций HttpMessageConverter. См. @RequestBody.
	
	17. HttpEntity<B> - Для доступа к заголовкам и телу запроса. Тело преобразуется с помощью HttpMessageConverter. Увидеть HttpEntity.
	
	18. @RequestPart - Для доступа к детали в запросе multipart/form-data преобразование тела детали с помощью HttpMessageConverter. Видеть Составные.
	
	19. java.util.Map, org.springframework.ui.Model, org.springframework.ui.ModelMap - используется для доступа к модели, которая используется в контроллерах HTML и предоставляется шаблонам как часть визуализации view.
	
	20. RedirectAttributes - Укажите атрибуты для использования в случае перенаправления (то есть для добавления в строку запроса) и атрибуты flash, которые будут временно храниться до запроса после перенаправления. Посмотреть атрибуты файлов и Флэш-атрибутами.
	
	21. @ModelAttribute - Для доступа к существующему атрибуту в модели (экземпляр, если он отсутствует) с привязкой и проверкой данных применяется. См. @ ModelAttribute, а также Model и DataBinder. Обратите внимание, что использование @ModelAttribute является необязательным (например, для установки его атрибутов). См. “любой другой аргумент” в конце этой таблицы.
	
	22. Errors, BindingResult - Для доступа к ошибкам из проверки и привязки данных для объекта команды (то есть аргумента @ModelAttribute) или ошибок из проверки аргументов @RequestBody или @RequestPart. Необходимо объявить аргумент Errors или BindingResult сразу после аргумента проверенного метода.
	
	23. SessionStatus + class-level @SessionAttributes - Для завершения обработки формы маркировки, которая запускает очистку атрибутов сеанса, объявленных через аннотацию @SessionAttributes уровня класса. Дополнительные сведения см. В разделе @SessionAttributes.
	
	24. UriComponentsBuilder - Для подготовки URL-адреса относительно хоста текущего запроса, порта, схемы, пути контекста и литеральной части сопоставления сервлетов. Видеть ссылки Ури.
	
	25. @SessionAttribute - Для доступа к любому атрибуту сеанса, в отличие от атрибутов модели, сохраненных в сеансе в результате объявления класса @SessionAttributes. Дополнительные сведения см. В разделе @SessionAttribute.
	
	26. @RequestAttribute - Для доступа к атрибутам запроса. Дополнительные сведения см. В разделе @RequestAttribute.
	
	27. Any other argument - Если аргумент метода не соответствует ни одному из предыдущих значений в этой таблице, и он является простым типом (как определено BeanUtils#isSimpleProperty, он разрешен как @RequestParam. В противном случае он разрешается как атрибут @ModelAttribute.
	
	
RETURNES VALUES - Возвращаемые значения методов контроллера

	1. @ResponseBody - Возвращаемое значение преобразуется с помощью реализаций HttpMessageConverter и записывается в ответ. Смотрите @ResponseBody
	
	2. HttpEntity<B>, ResponseEntity<B> - Возвращаемое значение, указывающее полный ответ (включая заголовки HTTP и тело), должно быть преобразовано через реализации HttpMessageConverter и записано в ответ. См. Раздел ResponseEntity
	
	3. HttpHeaders - Для возврата ответа с заголовками и без тела.
	
	4. String - Имя представления, разрешаемое с помощью реализаций ViewResolver и используемое вместе с неявной моделью, определяемой с помощью объектов command и методов @ModelAttribute. Метод обработчика также может программно заполнить модель, объявив аргумент модели (см. Explicit Registrations).
	
	5. View - Экземпляр представления, используемый для визуализации вместе с неявной моделью, определяемой с помощью командных объектов и методов @ModelAttribute. Метод обработчика также может программно обогатить модель, объявив аргумент модели (см.  Explicit Registrations).
	
	6. ModelAndView object - Используемые атрибуты представления и модели и, при необходимости, состояние ответа.
	
	7. void - Метод с типом возврата void (или возвращаемым значением null) считается полностью обработанным ответом, если он также имеет ServletResponse, аргумент OutputStream или аннотацию @ResponseStatus. То же самое верно и в том случае, если контроллер выполнил положительную проверку ETag или lastModified timestamp (Подробнее см. контроллеры).
	
	Если ни одно из вышеперечисленных значений не является истинным, возвращаемый тип void также может указывать “нет тела ответа " для контроллеров REST или выбор имени представления по умолчанию для контроллеров HTML.
	
	8. DeferredResult<V> - Произведите любое из предыдущих возвращаемых значений асинхронно из любого потока —	например, в результате некоторого события или обратного вызова. (См. раздел Asynchronous Requests и DeferredResult).
	
	9. Callable<V> - Создайте любое из вышеуказанных возвращаемых значений асинхронно в потоке, управляемом Spring MVC. См. раздел асинхронные запросы и вызываемые.
	
	10. ListenableFuture<V>, java.util.concurrent.CompletionStage<V>, java.util.concurrent.CompletableFuture<V> - Альтернатива DeferredResult, как удобство (например, когда базовая служба возвращает один из них).
	
	11. ResponseBodyEmitter, SseEmitter - Асинхронно выдавать поток объектов для записи в ответ с помощью реализаций HttpMessageConverter. Также поддерживается как тело ResponseEntity.
	
	12. StreamingResponseBody - Запись в ответ OutputStream асинхронно. Также поддерживается как тело ResponseEntity
	
	13. Reactive types — Reactor, RxJava, or others through ReactiveAdapterRegistry - Альтернатива DeferredResult с многозначными потоками (например, Flux, Observable), собранными в список. Для сценариев потоковой передачи (например, text/event-stream, application/json+stream) вместо этого используются SseEmitter и ResponseBodyEmitter, где блокирующий ввод-вывод ServletOutputStream выполняется на потоке, управляемом пружиной MVC, и обратное давление применяется против завершения каждой записи.
	
	14. Any other return value - Любое возвращаемое значение, которое не совпадает ни с одним из предыдущих значений в этой таблице и которое является строкой или void, рассматривается как имя представления (выбор имени представления по умолчанию через RequestToViewNameTranslator применяется), при условии, что это не простой тип, как определено BeanUtils#isSimpleProperty. Значения простых типов остаются неразрешенными.
	

Type Conversion - Преобразование типов

	Некоторые аннотированные аргументы метода контроллера, представляющие строковый вход запроса (например, @RequestParam, @RequestHeader, @PathVariable, @MatrixVariable и @CookieValue), могут потребовать преобразования типа, если аргумент объявлен как объект отличный от String.
	В таких случаях преобразование типов применяется автоматически на основе настроенных преобразователей. По умолчанию поддерживаются простые типы (int, long, Date и другие). Преобразование типов можно настроить с помощью WebDataBinder (см. DataBinder) или путем регистрации Форматеров в FormattingConversionService. См. Spring Field Formatting.
	

Matrix Variables - матричные переменные

	RFC 3986 описывает пары ключ-значение в сегментах пути. В Spring MVC мы называем их "матричными переменными “на основе” старого сообщения" Тима Бернерса-Ли, но их также можно назвать параметрами пути URI.
	Переменные матрицы могут отображаться в любом сегменте пути, причем каждая переменная разделяется точкой с запятой и несколькими значениями, разделенными запятой (например, /cars;color=red, green;year=2012). Несколько значений также можно задать с помощью повторяющихся имен переменных (например, color=red;color=green;color=blue).
	
	Использования матричных переменных необходимо включить. В конфигурации MVC Java необходимо установить UrlPathHelper с removeSemicolonContent=false через  Path Matching. В пространстве имен MVC XML можно задать <MVC: annotation-driven enable-matrix-variables="true"/>.
	
	Если предполагается, что URL-адрес может содержать матричные переменные, маппинг запроса для метода контроллера должно использовать переменную URI для маскировки содержимого этой переменной и обеспечения успешного маппинга запроса независимо от порядка и присутствия матричных переменных. В следующем примере используется матричная переменная:
	
		// GET /pets/42;q=11;r=22

		@GetMapping("/pets/{petId}")
		public void findPet(@PathVariable String petId, @MatrixVariable int q) {

			// petId == 42
			// q == 11
		}
	
	Учитывая, что все сегменты пути могут содержать матричные переменные, иногда может потребоваться устранить неоднозначность, в какой переменной пути ожидается переменная матрицы. В следующем примере показано, как это сделать:
	
		// GET /owners/42;q=11/pets/21;q=22

		@GetMapping("/owners/{ownerId}/pets/{petId}")
		public void findPet(
				@MatrixVariable(name="q", pathVar="ownerId") int q1,
				@MatrixVariable(name="q", pathVar="petId") int q2) {

			// q1 == 11
			// q2 == 22
		}
		
	Переменная матрицы может быть определена как необязательная и задано значение по умолчанию, как показано в следующем примере:
		
		// GET /pets/42

		@GetMapping("/pets/{petId}")
		public void findPet(@MatrixVariable(required=false, defaultValue="1") int q) {
			// q == 1
		}
		
	Чтобы получить все переменные матрицы, можно использовать многозначную карту, как показано в следующем примере:
	
		// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

		@GetMapping("/owners/{ownerId}/pets/{petId}")
		public void findPet(
				@MatrixVariable MultiValueMap<String, String> matrixVars,
				@MatrixVariable(pathVar="petId") MultiValueMap<String, String> petMatrixVars) {

			// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
			// petMatrixVars: ["q" : 22, "s" : 23]
		}



		
		
		
		
		
		
		
		