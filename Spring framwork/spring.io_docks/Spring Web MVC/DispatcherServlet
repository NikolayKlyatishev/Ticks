DispatcherServlet

DispatcherServlet - Spring MVC, как и многие другие веб-фреймворки, разработан вокруг шаблона front controller, где центральный сервлет - DispatcherServlet, предоставляет общий алгоритм обработки запросов, в то время как фактическая работа выполняется настраиваемыми компонентами делегата. Эта модель является гибкой и поддерживает различные рабочие процессы.

DispatcherServlet, как и любой сервлет, должен быть объявлен и сопоставлен в соответствии со спецификацией сервлета с помощью конфигурации Java или в web.xml. В свою очередь, DispatcherServlet использует конфигурацию Spring для обнаружения компонентов делегата, необходимых для сопоставления запросов, разрешения представлений, обработки исключений и т.д. 

Следующий пример конфигурации Java регистрирует и инициализирует DispatcherServlet, который автоматически обнаруживается контейнером сервлета (см. servlet Config):

		public class MyWebApplicationInitializer implements WebApplicationInitializer {

			@Override
			public void onStartup(ServletContext servletCxt) {

				// Загрузка конфигурации контекста, описанного в Java-классе
				AnnotationConfigWebApplicationContext appContext = new AnnotationConfigWebApplicationContext();
				appContext.register(AppConfig.class);
				appContext.refresh();
				
				// Загрузка конфигурации контекста, описанного в xml
				XmlWebApplicationContext appContext = new XmlWebApplicationContext();
				appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");

				// Добавление и регистрация DispatcherServlet
				DispatcherServlet servlet = new DispatcherServlet(appContext);
				ServletRegistration.Dynamic registration = servletCxt.addServlet("app", servlet);
				registration.setLoadOnStartup(1);
				registration.addMapping("/app/*");
			}
		}

СПЕЦИАЛЬНЫЕ ТИПЫ БИНОВ

DispatcherServlet делегирует специальные бины для обработки запросов и подготовки соответствующих ответов. Под "специальными бинами" мы подразумеваем экземпляры управляемых объектов Spring, которые реализуют рамочные интерсейсы. Они обычно поставляются со встроенными интерфейсами, но вы можете настроить их свойства, расширить или заменить их.

Типы бинов:

HandlerMapping - Перехватчики событий. Сопоставление запроса обработчику вместе со списком перехватчиков для предварительной и последующей обработки. Сопоставление основано на некоторых критериях, детали которых зависят от реализации HandlerMapping. Двумя основными реализациями HandlerMapping являются RequestMappingHandlerMapping (который поддерживает аннотированные методы @RequestMapping) и SimpleUrlHandlerMapping (который поддерживает явные регистрации шаблонов пути URI для обработчиков). 		
HandlerAdapter - помогает DispatcherServlet вызвать обработчик, сопоставленный с запросом, независимо от того, как фактически вызывается обработчик. Например, вызов аннотированного контроллера требует разрешения аннотаций. Основная цель HandlerAdapter-защитить DispatcherServlet от таких деталей.
HandlerExceptionResolver - Стратегия разрешения исключений, возможно сопоставление их с обработчиками, представлениями ошибок HTML или другими целевыми объектами. См. Раздел Исключения.
ViewResolver - Разрешите имена представлений на основе логических строк, возвращенные из обработчика, в фактическое представление, с помощью которого будет отображаться ответ. См. раздел Разрешение просмотра и технологии просмотра.
LocaleResolver, LocaleContextResolver - Разрешите Локаль, которую использует клиент, и, возможно, их часовой пояс, чтобы иметь возможность предлагать интернационализированные представления.
ThemeResolver - Разрешите темы, которые может использовать веб-приложение — например, чтобы предложить персонализированные макеты. Смотрите Темы.
MultipartResolver - Абстракция для разбора многосоставного запроса (например, загрузка файла формы браузера) с помощью некоторой библиотеки многосоставного разбора. Увидеть Составного Арбитра.
FlashMapManager - Храните и извлекайте флэш-карту “вход” и “выход”, которая может использоваться для передачи атрибутов от одного запроса к другому, обычно через перенаправление. Вижу Вспышки Атрибутами.



Web-MVC Config

Приложения могут объявлять бины инфраструктуры, перечисленные в специальных бинах, необходимых для обработки запросов. DispatcherServlet проверяет WebApplicationContext для каждого специального бина. Если соответствующие типы бинов отсутствуют, он возвращается к типам по умолчанию, перечисленным в DispatcherServlet.properties.


Servlet Config

WebApplicationInitializer-это интерфейс, предоставляемый Spring MVC, который гарантирует, что ваша реализация обнаружена и автоматически используется для инициализации любого контейнера Servlet 3. Абстрактная реализация базового класса WebApplicationInitializer с именем AbstractDispatcherServletInitializer упрощает регистрацию DispatcherServlet путем переопределения методов для указания сопоставления сервлетов и расположения конфигурации DispatcherServlet.

Это рекомендуется для приложений, использующих конфигурацию Spring на основе Java, как показано в следующем примере:

		public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

			@Override
			protected Class<?>[] getRootConfigClasses() {
				return null;
			}

			@Override
			protected Class<?>[] getServletConfigClasses() {
				return new Class<?>[] { MyWebConfig.class };
			}

			@Override
			protected String[] getServletMappings() {
				return new String[] { "/" };
			}
		}

AbstractDispatcherServletInitializer также предоставляет удобный способ добавления экземпляров фильтра и их автоматического сопоставления с DispatcherServlet, как показано в следующем примере:

		public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

			// ...

			@Override
			protected Filter[] getServletFilters() {
				return new Filter[] {
					new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };
			}
		}

Каждый фильтр добавляется с именем по умолчанию на основе его конкретного типа и автоматически сопоставляется с DispatcherServlet.

Isasyncsupported - защищенный метод AbstractDispatcherServletInitializer предоставляет одно место для включения асинхронной поддержки на DispatcherServlet и все фильтры, сопоставленные с ним. По умолчанию этот флаг имеет значение true.

Наконец, если вам нужно дополнительно настроить сам DispatcherServlet, вы можете переопределить метод createDispatcherServlet.


ПОРЯДОК ОБРАБОТКИ ЗАПРОСОВ ДИСПЕТЧЕРОМ СЕРВЛЕТОВ:

	- WebApplicationContext ищется и привязывается в запросе как атрибут, который может использовать контроллер и другие элементы выполнения. Он привязан по умолчанию под DispatcherServlet.key.WEB_APPLICATION_CONTEXT_ATTRIBUTE.
	- Преобразователь локали привязан к запросу, чтобы позволить элементам в процессе разрешить локаль для использования при обработке запроса (рендеринг представления, подготовка данных и т. д.). Если вам не нужно разрешение локали, вам не нужен преобразователь локали
	- theme resolver привязан к запросу, чтобы такие элементы, как представления, определяли, какую тему использовать. Если вы не используете темы, вы можете игнорировать его.
	- Если вы зададите составной преобразователь файлов, запрос будет проверен на наличие нескольких частей. При обнаружении нескольких частей запрос оборачивается в MultipartHttpServletRequest для дальнейшей обработки другими элементами процесса. Дополнительную информацию о многоэлементной обработке см. В разделе многоэлементный преобразователь.
	- Выполняется поиск соответствующего обработчика. Если обработчик найден, цепочка выполнения, связанная с обработчиком (препроцессоры, постпроцессоры и контроллеры), выполняется для подготовки модели или визуализации. Кроме того, для аннотированных контроллеров ответ может быть отображен (в пределах HandlerAdapter) вместо возврата представления.
	- Если модель возвращается, отображает представление. Если модель не возвращается (возможно, из-за препроцессора или постпроцессора, перехватывающего запрос, возможно, по соображениям безопасности), представление не отображается, потому что запрос уже мог быть выполнен.
	
Параметры инифиализации Диспетчера Сервлета:

	1. contextClass - Класс, реализующий ConfigurableWebApplicationContext, который будет создан и локально настроен этим сервлетом. По умолчанию используется XmlWebApplicationContext, для испрльзования аннотаций и java-кода используется класс AnnotationConfigWebApplicationContext.
	2. contextConfigLocation - Строка, которая передается в экземпляр контекста (объявленный contextClass), чтобы указать, где можно найти контексты. Строка потенциально состоит из нескольких строк (используя запятую в качестве разделителя) для поддержки нескольких контекстов. В случае нескольких расположений контекста с бобами, которые определены дважды, последнее расположение имеет приоритет.
	3. namespace - Пространство имен WebApplicationContext. По умолчанию [servlet-name] - сервлет
	4. throwExceptionIfNoHandlerFound - Следует ли создавать исключение NoHandlerFoundException, если для запроса не найден обработчик. Затем исключение можно перехватить с помощью HandlerExceptionResolver (например, с помощью метода контроллера @ExceptionHandler) и обрабатывать как любые другие. По умолчанию это значение равно false, и в этом случае DispatcherServlet устанавливает статус ответа 404 (NOT_FOUND) без создания исключения. Обратите внимание, что если также настроена обработка сервлета по умолчанию, неразрешенные запросы всегда пересылаются на сервлет по умолчанию и 404 никогда не вызывается.

	
Interception - перехват.
	Все реализации HandlerMapping поддерживают перехватчики обработчиков, которые полезны, когда вы хотите применить определенную функциональность к определенным запросам — например, проверка для участника. Перехватчики должны реализовать HandlerInterceptor из org.springframework.web.servlet пакет с тремя методами, которые должны обеспечить достаточную гибкость для выполнения всех видов предварительной и последующей обработки: 
	
	preHandle(..): Перед выполнением фактического обработчика

	postHandle(..): После выполнения обработчика

	afterCompletion(..): После завершения полного запроса
	
	preHandle(..) метод возвращает логическое значение. Этот метод можно использовать для прерывания или продолжения обработки цепочки выполнения. Когда этот метод возвращает true, цепочка выполнения обработчика продолжается. Когда он возвращает false, DispatcherServlet предполагает, что перехватчик сам позаботился о запросах (и, например, отрисовал соответствующее представление) и не продолжает выполнять другие перехватчики и фактический обработчик в цепочке выполнения.
	
	
ОБРАБОТКА ИСКЛЮЧЕНИЙ:

	Если исключение возникает во время сопоставления запроса или возникает из обработчика запроса (например, @Controller), DispatcherServlet делегирует цепочку компонентов HandlerExceptionResolver для разрешения исключения и обеспечения альтернативной обработки, которая обычно является ответом на ошибку.
	
	Ниже представлена список доступных реализаций интерфейса HandlerExceptionResolver.
	
	1. SimpleMappingExceptionResolver - привязка имени класса исключения к имени отображения ошибки. Используется для отображения 
	2. DefaultHandlerExceptionResolver - Разрешает исключения, вызванные Spring MVC, и сопоставляет их с кодами состояния HTTP. См. также альтернативные исключения ResponseEntityExceptionHandler и REST API.
	3. ResponseStatusExceptionResolver - Разрешает исключения с аннотацией @ResponseStatus и сопоставляет их с кодами состояния HTTP на основе значения в аннотации.
	4. ExceptionHandlerExceptionResolver - Разрешает исключения путем вызова метода @ExceptionHandler в классе @Controller или @ControllerAdvice. Ознакомиться с методами @ExceptionHandler.
	
	
	ЦЕПОЧКА ПРЕОБРАЗОВАНИЙ
	
	Вы можете сформировать цепочку преобразователей исключений, объявив несколько бинов HandlerExceptionResolver в конфигурации Spring и установив их свойства order по мере необходимости. Чем выше свойство order, тем позже позиционируется преобразователь исключений.
	
	Интерфейс HandlerExceptionResolver указывает, что он может возвращать:
	
		- ModelAndView, который указывает на представление ошибки.
		- Пустой ModelAndView, если исключение было обработано в преобразователе.
		- значение null, если исключение остается неразрешенным, для последующих преобразователей, чтобы попытаться, и, если исключение остается в конце, это позволяет всплывать до контейнера сервлета
	
	Конфигурация MVC автоматически объявляет встроенные преобразователи для исключений Spring MVC по умолчанию, для аннотированных исключений @ResponseStatus и для поддержки методов @ExceptionHandler. Вы можете настроить этот список или заменить его.
	
	
	Страница ошибки контейнера
	
	Если исключение остается неразрешенным любым HandlerExceptionResolver и поэтому остается для распространения или если состояние ответа установлено в состояние ошибки (то есть 4xx, 5xx), контейнеры сервлетов могут отображать страницу ошибки по умолчанию в HTML. Чтобы настроить страницу ошибок по умолчанию контейнера, можно объявить сопоставление страниц ошибок в web.XML. В следующем примере показано, как это сделать:
	
	<error-page>
		<location>/error</location>
	</error-page>
	
	В приведенном выше примере, когда исключение всплывает или ответ имеет статус ошибки, контейнер сервлета выполняет отправку ошибки в контейнере по настроенному URL (например, /error). Затем это обрабатывается DispatcherServlet, возможно, сопоставляя его с @ Controller, который может быть реализован для возврата имени представления ошибок с моделью или для отображения ответа JSON, как показано в следующем примере:
	
	@RestController
	public class ErrorController {

		@RequestMapping(path = "/error")
		public Map<String, Object> handle(HttpServletRequest request) {
			Map<String, Object> map = new HashMap<String, Object>();
			map.put("status", request.getAttribute("javax.servlet.error.status_code"));
			map.put("reason", request.getAttribute("javax.servlet.error.message"));
			return map;
		}
	}
	
	
	Разрешение просмотра (View Resolution)
	
	
	
	