DispatcherServlet

DispatcherServlet - Spring MVC, как и многие другие веб-фреймворки, разработан вокруг шаблона front controller, где центральный сервлет - DispatcherServlet, предоставляет общий алгоритм обработки запросов, в то время как фактическая работа выполняется настраиваемыми компонентами делегата. Эта модель является гибкой и поддерживает различные рабочие процессы.

DispatcherServlet, как и любой сервлет, должен быть объявлен и сопоставлен в соответствии со спецификацией сервлета с помощью конфигурации Java или в web.xml. В свою очередь, DispatcherServlet использует конфигурацию Spring для обнаружения компонентов делегата, необходимых для сопоставления запросов, разрешения представлений, обработки исключений и т.д. 

Следующий пример конфигурации Java регистрирует и инициализирует DispatcherServlet, который автоматически обнаруживается контейнером сервлета (см. servlet Config):

		public class MyWebApplicationInitializer implements WebApplicationInitializer {

			@Override
			public void onStartup(ServletContext servletCxt) {

				// Загрузка конфигурации контекста, описанного в Java-классе
				AnnotationConfigWebApplicationContext appContext = new AnnotationConfigWebApplicationContext();
				appContext.register(AppConfig.class);
				appContext.refresh();
				
				// Загрузка конфигурации контекста, описанного в xml
				XmlWebApplicationContext appContext = new XmlWebApplicationContext();
				appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");

				// Добавление и регистрация DispatcherServlet
				DispatcherServlet servlet = new DispatcherServlet(appContext);
				ServletRegistration.Dynamic registration = servletCxt.addServlet("app", servlet);
				registration.setLoadOnStartup(1);
				registration.addMapping("/app/*");
			}
		}

СПЕЦИАЛЬНЫЕ ТИПЫ БИНОВ

DispatcherServlet делегирует специальные бины для обработки запросов и подготовки соответствующих ответов. Под "специальными бинами" мы подразумеваем экземпляры управляемых объектов Spring, которые реализуют рамочные интерсейсы. Они обычно поставляются со встроенными интерфейсами, но вы можете настроить их свойства, расширить или заменить их.

Типы бинов:

HandlerMapping - Перехватчики событий. Сопоставление запроса обработчику вместе со списком перехватчиков для предварительной и последующей обработки. Сопоставление основано на некоторых критериях, детали которых зависят от реализации HandlerMapping. Двумя основными реализациями HandlerMapping являются RequestMappingHandlerMapping (который поддерживает аннотированные методы @RequestMapping) и SimpleUrlHandlerMapping (который поддерживает явные регистрации шаблонов пути URI для обработчиков). 		
HandlerAdapter - помогает DispatcherServlet вызвать обработчик, сопоставленный с запросом, независимо от того, как фактически вызывается обработчик. Например, вызов аннотированного контроллера требует разрешения аннотаций. Основная цель HandlerAdapter-защитить DispatcherServlet от таких деталей.
HandlerExceptionResolver - Стратегия разрешения исключений, возможно сопоставление их с обработчиками, представлениями ошибок HTML или другими целевыми объектами. См. Раздел Исключения.
ViewResolver - Разрешите имена представлений на основе логических строк, возвращенные из обработчика, в фактическое представление, с помощью которого будет отображаться ответ. См. раздел Разрешение просмотра и технологии просмотра.
LocaleResolver, LocaleContextResolver - Разрешите Локаль, которую использует клиент, и, возможно, их часовой пояс, чтобы иметь возможность предлагать интернационализированные представления.
ThemeResolver - Разрешите темы, которые может использовать веб-приложение — например, чтобы предложить персонализированные макеты. Смотрите Темы.
MultipartResolver - Абстракция для разбора многосоставного запроса (например, загрузка файла формы браузера) с помощью некоторой библиотеки многосоставного разбора. Увидеть Составного Арбитра.
FlashMapManager - Храните и извлекайте флэш-карту “вход” и “выход”, которая может использоваться для передачи атрибутов от одного запроса к другому, обычно через перенаправление. Вижу Вспышки Атрибутами.



Web-MVC Config

Приложения могут объявлять бины инфраструктуры, перечисленные в специальных бинах, необходимых для обработки запросов. DispatcherServlet проверяет WebApplicationContext для каждого специального бина. Если соответствующие типы бинов отсутствуют, он возвращается к типам по умолчанию, перечисленным в DispatcherServlet.properties.


Servlet Config

WebApplicationInitializer-это интерфейс, предоставляемый Spring MVC, который гарантирует, что ваша реализация обнаружена и автоматически используется для инициализации любого контейнера Servlet 3. Абстрактная реализация базового класса WebApplicationInitializer с именем AbstractDispatcherServletInitializer упрощает регистрацию DispatcherServlet путем переопределения методов для указания сопоставления сервлетов и расположения конфигурации DispatcherServlet.

Это рекомендуется для приложений, использующих конфигурацию Spring на основе Java, как показано в следующем примере:

		public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

			@Override
			protected Class<?>[] getRootConfigClasses() {
				return null;
			}

			@Override
			protected Class<?>[] getServletConfigClasses() {
				return new Class<?>[] { MyWebConfig.class };
			}

			@Override
			protected String[] getServletMappings() {
				return new String[] { "/" };
			}
		}

AbstractDispatcherServletInitializer также предоставляет удобный способ добавления экземпляров фильтра и их автоматического сопоставления с DispatcherServlet, как показано в следующем примере:

		public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

			// ...

			@Override
			protected Filter[] getServletFilters() {
				return new Filter[] {
					new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };
			}
		}

Каждый фильтр добавляется с именем по умолчанию на основе его конкретного типа и автоматически сопоставляется с DispatcherServlet.

Isasyncsupported - защищенный метод AbstractDispatcherServletInitializer предоставляет одно место для включения асинхронной поддержки на DispatcherServlet и все фильтры, сопоставленные с ним. По умолчанию этот флаг имеет значение true.

Наконец, если вам нужно дополнительно настроить сам DispatcherServlet, вы можете переопределить метод createDispatcherServlet.


ПОРЯДОК ОБРАБОТКИ ЗАПРОСОВ ДИСПЕТЧЕРОМ СЕРВЛЕТОВ:

	- WebApplicationContext ищется и привязывается в запросе как атрибут, который может использовать контроллер и другие элементы выполнения. Он привязан по умолчанию под DispatcherServlet.key.WEB_APPLICATION_CONTEXT_ATTRIBUTE.
	- Преобразователь локали привязан к запросу, чтобы позволить элементам в процессе разрешить локаль для использования при обработке запроса (рендеринг представления, подготовка данных и т. д.). Если вам не нужно разрешение локали, вам не нужен преобразователь локали
	- theme resolver привязан к запросу, чтобы такие элементы, как представления, определяли, какую тему использовать. Если вы не используете темы, вы можете игнорировать его.
	- Если вы зададите составной преобразователь файлов, запрос будет проверен на наличие нескольких частей. При обнаружении нескольких частей запрос оборачивается в MultipartHttpServletRequest для дальнейшей обработки другими элементами процесса. Дополнительную информацию о многоэлементной обработке см. В разделе многоэлементный преобразователь.
	- Выполняется поиск соответствующего обработчика. Если обработчик найден, цепочка выполнения, связанная с обработчиком (препроцессоры, постпроцессоры и контроллеры), выполняется для подготовки модели или визуализации. Кроме того, для аннотированных контроллеров ответ может быть отображен (в пределах HandlerAdapter) вместо возврата представления.
	- Если модель возвращается, отображает представление. Если модель не возвращается (возможно, из-за препроцессора или постпроцессора, перехватывающего запрос, возможно, по соображениям безопасности), представление не отображается, потому что запрос уже мог быть выполнен.
	
Параметры инициализации Диспетчера Сервлета:

	1. contextClass - Класс, реализующий ConfigurableWebApplicationContext, который будет создан и локально настроен этим сервлетом. По умолчанию используется XmlWebApplicationContext, для испрльзования аннотаций и java-кода используется класс AnnotationConfigWebApplicationContext.
	2. contextConfigLocation - Строка, которая передается в экземпляр контекста (объявленный contextClass), чтобы указать, где можно найти контексты. Строка потенциально состоит из нескольких строк (используя запятую в качестве разделителя) для поддержки нескольких контекстов. В случае нескольких расположений контекста с бобами, которые определены дважды, последнее расположение имеет приоритет.
	3. namespace - Пространство имен WebApplicationContext. По умолчанию [servlet-name] - сервлет
	4. throw NoHandlerFoundException - если для запроса не найден обработчик. Затем исключение можно перехватить с помощью HandlerExceptionResolver (например, с помощью метода контроллера @ExceptionHandler) и обрабатывать как любые другие. По умолчанию это значение равно false, и в этом случае DispatcherServlet устанавливает статус ответа 404 (NOT_FOUND) без создания исключения. Обратите внимание, что если также настроена обработка сервлета по умолчанию, неразрешенные запросы всегда пересылаются на сервлет по умолчанию и 404 никогда не вызывается.

	
Interception - перехват.

	Все реализации HandlerMapping поддерживают перехватчики обработчиков, которые полезны, когда вы хотите применить определенную функциональность к определенным запросам — например, проверка для участника. Перехватчики должны реализовать HandlerInterceptor из org.springframework.web.servlet пакет с тремя методами, которые должны обеспечить достаточную гибкость для выполнения всех видов предварительной и последующей обработки: 
	
	preHandle(..): Перед выполнением фактического обработчика

	postHandle(..): После выполнения обработчика

	afterCompletion(..): После завершения полного запроса
	
	preHandle(..) метод возвращает логическое значение. Этот метод можно использовать для прерывания или продолжения обработки цепочки выполнения. Когда этот метод возвращает true, цепочка выполнения обработчика продолжается. Когда он возвращает false, DispatcherServlet предполагает, что перехватчик сам позаботился о запросах (и, например, отрисовал соответствующее представление) и не продолжает выполнять другие перехватчики и фактический обработчик в цепочке выполнения.
	
	
ОБРАБОТКА ИСКЛЮЧЕНИЙ:

	Если исключение возникает во время сопоставления запроса или возникает из обработчика запроса (например, @Controller), DispatcherServlet делегирует цепочку компонентов HandlerExceptionResolver для разрешения исключения и обеспечения альтернативной обработки, которая обычно является ответом на ошибку.
	
	Ниже представлена список доступных реализаций интерфейса HandlerExceptionResolver.
	
	1. SimpleMappingExceptionResolver - привязка имени класса исключения к имени отображения ошибки. Используется для отображения 
	2. DefaultHandlerExceptionResolver - Разрешает исключения, вызванные Spring MVC, и сопоставляет их с кодами состояния HTTP. См. также альтернативные исключения ResponseEntityExceptionHandler и REST API.
	3. ResponseStatusExceptionResolver - Разрешает исключения с аннотацией @ResponseStatus и сопоставляет их с кодами состояния HTTP на основе значения в аннотации.
	4. ExceptionHandlerExceptionResolver - Разрешает исключения путем вызова метода @ExceptionHandler в классе @Controller или @ControllerAdvice. Ознакомиться с методами @ExceptionHandler.
	
	
ЦЕПОЧКА ПРЕОБРАЗОВАНИЙ ИСКЛЮЧЕНИЙ.
	
	Вы можете сформировать цепочку преобразователей исключений, объявив несколько бинов HandlerExceptionResolver в конфигурации Spring и установив их свойства order по мере необходимости. Чем выше свойство order, тем позже позиционируется преобразователь исключений.
	
	Интерфейс HandlerExceptionResolver указывает, что он может возвращать:
	
		- ModelAndView, который указывает на представление ошибки.
		- Пустой ModelAndView, если исключение было обработано в преобразователе.
		- значение null, если исключение остается неразрешенным, для последующих преобразователей, чтобы попытаться, и, если исключение остается в конце, это позволяет всплывать до контейнера сервлета
	
	Конфигурация MVC автоматически объявляет встроенные преобразователи для исключений Spring MVC по умолчанию, для аннотированных исключений @ResponseStatus и для поддержки методов @ExceptionHandler. Вы можете настроить этот список или заменить его.
	
	
СТРАНИЦА ОШИБКИ КОНТЕЙНЕРА
	
	Если исключение остается неразрешенным любым HandlerExceptionResolver и поэтому остается для распространения или если состояние ответа установлено в состояние ошибки (то есть 4xx, 5xx), контейнеры сервлетов могут отображать страницу ошибки по умолчанию в HTML. Чтобы настроить страницу ошибок по умолчанию контейнера, можно объявить сопоставление страниц ошибок в web.XML. В следующем примере показано, как это сделать:
	
	<error-page>
		<location>/error</location>
	</error-page>
	
	В приведенном выше примере, когда исключение всплывает или ответ имеет статус ошибки, контейнер сервлета выполняет отправку ошибки в контейнере по настроенному URL (например, /error). Затем это обрабатывается DispatcherServlet, возможно, сопоставляя его с @ Controller, который может быть реализован для возврата имени представления ошибок с моделью или для отображения ответа JSON, как показано в следующем примере:
	
	@RestController
	public class ErrorController {

		@RequestMapping(path = "/error")
		public Map<String, Object> handle(HttpServletRequest request) {
			Map<String, Object> map = new HashMap<String, Object>();
			map.put("status", request.getAttribute("javax.servlet.error.status_code"));
			map.put("reason", request.getAttribute("javax.servlet.error.message"));
			return map;
		}
	}
	
	
Разрешение просмотра (View Resolution)
	
	Spring MVC определяет интерфейсы ViewResolver и View, которые позволяют отображать модели в браузере, не привязывая вас к определенной технологии представления. ViewResolver обеспечивает сопоставление между именами представлений и фактическими представлениями. View относится к подготовке данных перед передачей определенной технологии просмотра.
	
	Реализации ViewResolver:
	
	1. AbstractCachingViewResolver - Подклассы экземпляров представления кэша AbstractCachingViewResolver. Кэширование повышает производительность некоторых технологий представления. Вы можете отключить кэш, установив для свойства cache значение false. Кроме того, если необходимо обновить определенное представление во время выполнения (например, при изменении шаблона FreeMarker), можно использовать метод removeFromCache(String viewName, Locale loc).
	2. XmlViewResolver - Реализация ViewResolver, которая принимает файл конфигурации, написанный в XML с тем же DTD, что и фабрики XML-компонентов Spring. Файл конфигурации по умолчанию - /WEB-INF / views.XML.
	3. ResourceBundleViewResolver - Реализация ViewResolver, который использует определения bean в ResourceBundle, заданном базовым именем пакета. Для каждого представления, которое он должен разрешить, он использует значение свойства [viewname].(class) как класс представления и значение свойства [viewname].url-адрес в качестве URL-адреса представления. Примеры можно найти в главе, посвященной технологиям просмотра.
	4. UrlBasedViewResolver - Простая реализация интерфейса ViewResolver, который влияет на прямое разрешение логических имен представлений в URL-адреса без явного определения сопоставления. Это уместно, если ваши логические имена совпадают с именами ресурсов представления простым способом, без необходимости произвольных сопоставлений.
	5. InternalResourceViewResolver - Удобный подкласс UrlBasedViewResolver, который поддерживает InternalResourceView (по сути, сервлеты и JSP) и подклассы, такие как JstlView и TilesView. Вы можете указать класс представления для всех представлений, созданных этим преобразователем, с помощью setViewClass(..). См. UrlBasedViewResolver javadoc.
	6. FreeMarkerViewResolver - Удобный подкласс UrlBasedViewResolver, который поддерживает FreeMarkerView и пользовательские подклассы из них
	7. ContentNegotiatingViewResolver - Реализация интерфейса ViewResolver, который разрешает представление на основе имени файла запроса или заголовка Accept. См. Content Negotiation.
	
	
	Handling - обработка.
	
	Интерфейс ViewResolver может возвращать значение null, если представление не найдено. Однако в случае JSP и InternalResourceViewResolver единственным способом выяснить, существует ли JSP, является выполнение отправки через RequestDispatcher. Поэтому необходимо всегда настраивать InternalResourceViewResolver, чтобы он был последним в общем порядке преобразователей представлений.
	
	Настройка ViewResolver так же проста, как добавление компонентов ViewResolver в конфигурацию Spring. Конфигурация MVC предоставляет выделенный API конфигурации для преобразователей представлений и для добавления контроллеров представления без логики, которые полезны для рендеринга шаблонов HTML без логики контроллера.
	
	
	Redirecting - переадресация
	
	Специальный префикс redirect: в имени View позволяет выполнять перенаправление. UrlBasedViewResolver (и его подклассы) распознают это как инструкцию о необходимости перенаправления. Остальная часть имени View - это URL-адрес перенаправления.
	
	Чистый эффект такой же, как если бы контроллер вернул RedirectView, но теперь сам контроллер может работать с точки зрения логических имен представлений. Логическое имя представления (например, redirect:/myapp/some/resource) перенаправляет по отношению к текущему контексту сервлета, в то время как имя, такое как redirect:https://myhost.com/some/arbitrary/path перенаправляет на абсолютный URL-адрес.
	
	Обратите внимание, что если метод контроллера аннотируется с помощью @ResponseStatus, значение аннотации имеет приоритет над состоянием ответа, установленным RedirectView.
	
	
	Forwarding - Пересылка
	
	Вы также можете использовать специальный префикс forward: для имен представлений, которые в конечном итоге разрешаются с помощью UrlBasedViewResolver и подклассов. Это создаст InternalResourceView, который выполнит RequestDispatcher.forward(). Поэтому этот префикс не полезен с InternalResourceViewResolver и InternalResourceView (для JSP), но он может быть полезен, если вы используете другую технологию представления, но все же хотите принудительно перенаправить ресурс, который будет обрабатываться механизмом Servlet/JSP. Обратите внимание, что вместо этого можно также связать несколько сопоставителей представлений.
	
	
	Content Negotiation - Согласование содержания.
	
	ContentNegotiatingViewResolver не может выбрать view самостоятельно, а делегирует выбор другим механизмам представлений и выбирает view, похожее на view, запрошенное клиентом. Представление может быть определено из заголовка Accept или из параметра запроса (например, "/path?format=pdf").
	
	ContentNegotiatingViewResolver выбирает соответствующее view для обработки запроса путем сравнения типов носителей запроса с типом носителя (также известным как Content-Type), поддерживаемым view, связанным с каждым из его ViewResolvers. Первое представление в списке, которое имеет совместимый тип контента, возвращает представление клиенту. Если совместимое представление не может быть предоставлено цепочкой ViewResolver, следует обратиться к списку представлений, указанных в свойстве DefaultViews. Этот последний вариант подходит для одноэлементных представлений, которые могут отображать соответствующее представление текущего ресурса независимо от имени логического представления. Заголовок Accept может содержать подстановочные знаки (например, text/*), и в этом случае представление с типом содержимого text/xml является совместимым.
	
	
LOCALE - локализация.
	
	Большинство частей архитектуры Spring поддерживают интернационализацию, как это делает Spring web MVC framework. DispatcherServlet позволяет автоматически сделать выбор в сторону языкового стандарта клиента. Это делается с помощью объектов LocaleResolver.
	
	Когда приходит запрос, DispatcherServlet ищет преобразователь языкового стандарта и, если он находит его - пытается использовать для установки локализации. С помощью RequestContext.getLocale(), вы всегда можете получить языковой стандарт, который был выбран преобразователем языкового стандарта.
	
	В дополнение к автоопределению локализации можно также добавить перехватчик к сопоставлени обработчика (см. Перехват для получения дополнительной информации о перехватчиках сопоставления обработчиков), чтобы изменить локализацию при определенных обстоятельствах (например, на основе параметра в запросе).
	
TIME ZONE - часовой пояс
	
	Помимо получения локализации клиента, часто полезно знать его часовой пояс. Интерфейс LocaleContextResolver предлагает расширение для LocaleResolver, которое позволяет преобразователям предоставлять более богатый LocaleContext, который может включать информацию о часовом поясе.

	Если доступно, часовой пояс пользователя может быть получен с помощью RequestContext.getTimeZone(). Информация о часовом поясе автоматически используется любым преобразователем даты / времени и объектами форматирования, зарегистрированными в Spring's ConversionService.
	
	Header Resolver - Устройство Для Преобразования Заголовков
	
	Этот преобразователь языковых стандартов проверяет заголовок accept-language в запросе, отправленном клиентом (например, веб-браузером). Обычно это поле заголовка содержит языковой стандарт операционной системы клиента. Обратите внимание, что этот преобразователь не поддерживает информацию о часовом поясе.
	
	Cookie Resolver - преобразователь куки.
	
	Этот преобразователь локализации анализирует куки, которые есть на клиенте и, если возможно - устанавливают локализацию (local) или временную зону (TimeZone). С помощью свойств этого преобразователя локали можно указать имя файла cookie, а также максимальный возраст. В следующем примере определяется CookieLocaleResolver:
	
		<bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver">

			<property name="cookieName" value="clientlanguage"/>

			<!-- в секундах, если установлено -1 - куки не сохраняется (будет удалено браузером при закрытии.) -->
			<property name="cookieMaxAge" value="100000"/>

		</bean>

	Ниже описаны некоторые свойства CookieLocaleResolver и их описание:
	
	1. cookieName - Имя файла куки (по умолчанию установлено classname + LOCALE)
	2. cookieMaxAge - Максмальное время сохранения файла куки на клиенте. Если установлено -1 - куки будет уничтожаться после закрытия браузера.
	3. cookiePath - Ограничивает видимость файла cookie для определенной части вашего сайта. Если указан cookiePath, файл cookie виден только для этого пути и ниже. Значение по умолчанию "/"

	Session Resolver - Преобразователь сессий
	
	SessionLocaleResolver - позволяет узнать локализацию и временную зону для сессии, которая связана с польховательским запросом. В отличие от CookieLocaleResolver, эта стратегия поиска устанавливает параметр HttpSession в контейнере сервлета. Эти настроки являются временными для каждого сеанса и поэтому пропадут после завершения сеанса.
	Обратите внимание, что нет прямой связи с внешними механизмами управления сеансами, такими как Spring Session project. SessionLocaleResolver вычисляет и изменяет соответствующий атрибут HttpSession для текущего HttpServletRequest.
	
	Перехватчик локализации - Locale Interceptor
	
	Вы можете включить изменение локалей, добавив LocaleChangeInterceptor в одно из определений HandlerMapping. Он находит параметр в запросе и соответственно изменяет языковой стандарт, вызывая метод setLocale на LocaleResolver в контексте приложения диспетчера. Следующий пример показывает, что вызовы для всех *.view ресурсов, содержащих параметр siteLanguage, изменит языковой стандарт. Так, например, запрос на URL, https://www.sf.net/home.view?siteLanguage=nl, изменяет язык сайта на голландский. В следующем примере показано, как перехватить локаль:
	
	<bean id="localeChangeInterceptor" 
		class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor">
		<property name="paramName" value="siteLanguage"/>
	</bean>

	<bean id="localeResolver"
        class="org.springframework.web.servlet.i18n.CookieLocaleResolver"/>

	<bean id="urlMapping"
        class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
		<property name="interceptors">
			<list>
				<ref bean="localeChangeInterceptor"/>
			</list>
		</property>
		<property name="mappings">
			<value>/**/*.view=someController</value>
		</property>
	</bean>
	
	
THEMES - темы
	
	Вы можете применить темы Spring Web MVC framework для настройки общего внешнего вида вашего приложения, тем самым улучшая пользовательский интерфейс. Тема-это набор статических ресурсов, обычно таблиц стилей и изображений, которые влияют на визуальный стиль приложения.
	
	Подробнее можно прочитать в документации на сайте https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-viewresolver
	
	
MULTIPART RESOLVER - составной преобразователь
	
	MultipartResolver в пакете org.springframework.web.multipart - это стратегия для разбора составных запросов, включая загрузку файлов. Существует 2 реализации - одна, основанная на Commons FileUpload, а другая - на анализе составных запросов Servlet 3.0.
	
	Чтобы включить многоэлементную обработку, необходимо объявить компонент MultipartResolver в конфигурации DispatcherServlet Spring с именем multipartResolver. DispatcherServlet обнаруживает его и применяет к входящему запросу. Когда сообщение с типом содержимого multipart/form-data получено, преобразователь анализирует содержимое и обертывает текущий HttpServletRequest как MultipartHttpServletRequest, чтобы обеспечить доступ к разрешенным частям в дополнение к предоставлению их в качестве параметров запроса.
	
	
	Apache Commons FileUpload
	
	Для использования Apache Commons FileUpload можно настроить компонент типа CommonsMultipartResolver с именем multipartResolver. Для использования вы должны подключить зависимость commons-fileupload.
	
	Servlet 3.0
	
	Многопартийный синтаксический анализ сервлета 3.0 должен быть включен через конфигурацию контейнера сервлета. Это можно сделать так:
	
		1. В Java установите MultipartConfigElement при регистрации сервлета.
		2. В web.xml, добавьте раздел "<multipart-config>" при объявлении сервлета
	
	Следующий пример показывает, как установить MultipartConfigElement при регистрации сервлета:
	
		public class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

		// ...
			@Override
			protected void customizeRegistration(ServletRegistration.Dynamic registration) {

				// Дополнительно можно установить maxFileSize, maxRequestSize, fileSizeThreshold
				registration.setMultipartConfig(new MultipartConfigElement("/tmp"));
			}
		}
		
	После установки конфигурации сервлета 3.0 можно добавить компонент типа StandardServletMultipartResolver с именем multipartResolver.
	
	
	