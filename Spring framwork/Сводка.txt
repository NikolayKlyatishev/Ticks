
Состав Spring MVC (5.1):

	Спринг - фреймворк управления компонентами (Бинами). Все бины объединяются в контекст приложения. Сужествуют 2 вида контекстов: Корневой и дочерний контакст. Спринг может обновременно содержать несколько контекстов, один будет корневым, остальные дочерними. Все бины, объявленные в дочерних контекстах могут получить доступ к бинам корневого контекста, но не наоборот.
	
	Dispatcher Servlet - дочерий контекст приложения. Является сервлетом, основная цель которого  - обрабатывать входящие http-запросы, соовтетсвующие настроенному шаблону URL. Диспетчер принимает входящий URL и находит правльную комбинацию контроллера и представления. При определении Dispatcher Servlet мы должны передать xml файл с объявлением классов компонентов в артибут с именем contextConfigLocation. Если этого не сделать, Spring попытается найти xml файл с именем, соответсвующим шаблону webapp/WEB-INF/[servlet_name]-servlet.xml В web-приложениями одновременно могут быть объявлены неограниченное количество dispatcher servlet, каждый из которых будет работать в своем пространстве имен с собственными загружаемыми контекстами. Начиная с версии Spring 3.x несколько Dispatcher servlet могут работать с общим контекстом. Это возможно при помощи метода ServletContext.addServlet(String, String)

	1. Dispatcher Servlet - сервлет, предоставляющий алгоритм обработки запросов. Основной обработчик, который обрабатывает все входящие http запросы.
	2. Конфигурационный класс.
	
	ContextLoaderListener - корневой контекст приложения. Данный класс создает корневой контекст приложения. Этот контекст может использоваться всеми Dispatcher Servlet-ами. Запись в web.xml с объявлением ContextLoaderListener может быть только одна. После создания корневого контекста он может быть сохранен в атрибуте при помощи:
	
	servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);
	WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE = WebApplicationContext.class.getName() + ".ROOT";
	
	1. ContextLoaderListener создает корневой контекст приложения.
	2. Записи о DispatcherServlet создают один контекст дочернего приложения для каждой записи сервлета.
	3. Дочерние контексты могут обращаться к бинам, определенным в корневом контексте.
	4. Бины в корневом контексте не могут получить доступ к бинам в дочерних контекстах (напрямую).
	5. Все контексты добавляются в ServletContext.
	6. Вы можете получить доступ к корневому контексту с помощью WebApplicationContextUtils.
	
-----------------------------------------------------------------------------------	
1. DISPATCHER SERVLET


	Dispatcher Servlet - сервлет, предоставляющий алгоритм обработки запросов. Может быть объявлен как в web.xml, так и при помощи java-конфигурации без использования web.xml. 
	Рассматриваю только java-конфигурирование.
	Dispatcher servlet использует конфигурацию Spring для поиска используемых компонентов, таких как обработчики сопоставления запросов, обработчики испключений и т.д.
	
	Пример инициализации DispatcherServlet:
	
		public class MyWebApplicationInitializer implements WebApplicationInitializer {

			@Override
			public void onStartup(ServletContext servletCxt) {

				// Загрузка конфигурации контекста, описанного в Java-классе
				AnnotationConfigWebApplicationContext appContext = new AnnotationConfigWebApplicationContext();
				appContext.register(AppConfig.class);
				appContext.refresh();
				
				// Добавление и регистрация DispatcherServlet
				DispatcherServlet servlet = new DispatcherServlet(appContext);
				ServletRegistration.Dynamic registration = servletCxt.addServlet("app", servlet);
				registration.setLoadOnStartup(1);
				registration.addMapping("/app/*");
			}
		}
		
	DispatcherServlet передает бины	для обработки запросов и подготовки соответствующих ответов.
	
	
	
	Настраиваемые Интерфейсы:
		
		1. HandlerMapping - Перехватчики событий. Сопоставление запроса обработчику вместе со списком перехватчиков для предварительной и последующей обработки. основными реализациями HandlerMapping являются RequestMappingHandlerMapping (который поддерживает аннотированные методы @RequestMapping) и SimpleUrlHandlerMapping (который поддерживает явные регистрации шаблонов пути URI для обработчиков). 		 
		2. HandlerAdapter - помогает DispatcherServlet вызвать обработчик, соответствующий запросу. По факту является мостом между диспетчером и контроллером.
		3. HandlerExceptionResolver - обработчик разрешения исключений, возможно сопоставление их с обработчиками, представлениями ошибок в HTML.
		4. ViewResolver - обработчик выбора представлений на основе строки - имени представления.
		5. LocaleResolver, LocaleContextResolver - обработчик, помогающий установить локализацию клиента.
		6. ThemeResolver - обработчик, позволяющий применять различные темы оформления.
		7. MultipartResolver - оьработчик, способный разобрать составные запросы.
		8. FlashMapManager - Обработчик, позволяющий передавать артибуты между запросами. Обычно реализуется через перенаправление.
		
	DispatcherServlet проверяет WebApplicationContext на предмет наличия каждого из перечисленных интерфейсов, если бины с таким типом отсутствуют, он использует типы по умолчанию, перечисленные в DispatcherServlet.properties.	
	

	-----------------------------------------------------------------------------------
	Конфигурирование Сервлета:
		
		Конфигурирование сервлета выполняется классом, наследником абстрактного класса AbstractContextLoaderInitializer и реализующим интерфейс WebApplicationInitializer с единственным методом onStartup(ServletContext var1).
		
		public class MyWebAppInitializer implements WebApplicationInitializer {
    
			public void onStartup(ServletContext container) {
				  // Добавляем главный контекст приложения Spring.
				  AnnotationConfigWebApplicationContext rootContext = new AnnotationConfigWebApplicationContext();
				  rootContext.register(AppConfig.class);
		 
				  // Устанавливаем длительность жизненного цикла для главного контекста приложения.
				  container.addListener(new ContextLoaderListener(rootContext));
			
				  // Добавляем диспетчер сервлетов для контакста приложения Spring.
				  AnnotationConfigWebApplicationContext dispatcherContext = new AnnotationConfigWebApplicationContext();
				  dispatcherContext.register(DispatcherConfig.class);
			
				  // Регистрируем и привязываем диспетчер сервлет в URL, т.е. в нашем случае обрабатываются все http запросы.
				  ServletRegistration.Dynamic dispatcher = container.addServlet("dispatcher", new DispatcherServlet(dispatcherContext));
				  dispatcher.setLoadOnStartup(1);
				  dispatcher.addMapping("/");
			}
	
	При необходимости настройки диспетчера сервлетов можно переопределить метод createDispatcherServlet().
	
	При необходимости, мы можем унаследоваться от AbstractAnnotationConfigDispatcherServletInitializer, переопределить методы getRootConfigClasses (Принимает конфигурационный класс контекста приложения) и getServletConfigClasses (Принимает конфигурационный класс контекста сервлета приложения). 
		
	Класс AbstractDispatcherServletInitializer предоставляет удобный способ добавления фильтра и автоматического сопоставления с диспетчером сервлетов на основе возвращаемого типа.
		
	Параметры инициализации Диспетчера Сервлета:	
		1. Устанавливается класс, реализующий ConfigurableWebApplicationContex, если испрльзуются аннотации и java-код - используется класс AnnotationConfigWebApplicationContext.
		2. contextConfigLocation - строка, отражающая путь к контекстам. Возможно указание через запятую (если файлов с контекстами несколько), если в нескольких контекстах есть описание одного и того же бина - приоритет имеет последний указанный путь. 
		3. namespace - Пространство имен WebApplicationContext. По умолчанию [servlet-name] - сервлет
		4. throw ExceptionIfNoHandlerFound - обработка исключительных ситуаций, если для запроса не найден обработчик. Может быть перехвачен при помощи HandlerExceptionResolver и далее обработан так же как и прочие исключения.	
		
	Принцип и порядок обработки запросов диспетчером сервлетов:
		1. Диспетчер сервлет ищет WebApplicationContext и привязывает его по-умолчанию как артибут DispatcherServlet.key.WEB_APPLICATION_CONTEXT_ATTRIBUTE. Затем этот атрибут может использоваться другими компонентами программы (контроллерами и т.п.).
		2. К запросу привязывается Обработчик локализации, для определения текущей локализации. Если не нужно определение локализации, LocaleResolver можно не использовать.
		3. К запросу приаязывается theme resolver - определяющий используемую тему. Если темы не используются - ThemeResolver можно не указывать.
		4. Если вы зададите составной преобразователь файлов, запрос проверяется на наличие составных частей. При обнаружении нескольких частей запрос оборачивается в MultipartHttpServletRequest
		5. Выполняется поиск соответствующего обработчика. Если обработчик найден, выполняется логика, связанная с обработчиком (препроцессоры, постпроцессоры и контроллеры), выполняется подготовка визуализации. Кроме того, для аннотированных контроллеров ответ может быть отображен (в пределах HandlerAdapter) вместо представления.
		6. Если была определена модель - возвращаем представление модели, если нет - возвращаем представление ошибки (причины, по которым не возвращено представление).
		
	
	-----------------------------------------------------------------------------------
	Interception - перехват запросов.
	
	Перехватчик запросов - класс, реализующий HandlerInterceptor из пакета org.springframework.web.servlet. Для работы перехватчика мы должны зарегистрировать его в конфигурационном классе (отмеченным аннотацией @Configuration) в методе void addInterceptors(InterceptorRegistry registry) {}
	
	Добавление выполяется методом registry.addInterceptor(HandlerInterceptor interCeptor)
			
		Пример:
			@Configuration
			@EnableWebMvc
			public class WebConfig implements WebMvcConfigurer {

				@Override
				public void addInterceptors(InterceptorRegistry registry) {
					registry.addInterceptor(new ThemeChangeInterceptor()).addPathPatterns("/**").excludePathPatterns("/admin/**");
				}
			}
			
	Интерфейс HandlerInterceptor предлагает 3 метода для реализации:
		boolean preHandle(..): перехват перед выполнением фактического обработчика
		void postHandle(..): перехват после выполнения обработчика
		void afterCompletion(..): перехват после завершения обработки запроса, то есть после рендеринга представления
			
	
	-----------------------------------------------------------------------------------
	Exception - обработка исключений
		
	Классы, реализующие интерфейс HandlerExceptionResolver могут обрабатывать исключительные ситуации, возникающие при работе программы. Результатом может быть ModelAndView, указывающий на представление ошибки, пустой ModelAndView (сли исключение было обработано в преобразователе) или null (в этом случае исключение остается неразрешенным). 
		
	Интерфейс содержит метод, resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex), в котором можеть быть реализована логика обработки исключения.
			
		1. SimpleMappingExceptionResolver - привязка имени класса исключения к имени отображения ошибки. Используется для отображения 
		2. DefaultHandlerExceptionResolver - Разрешает исключения, вызванные Spring MVC, и сопоставляет их с кодами состояния HTTP. См. также альтернативные исключения ResponseEntityExceptionHandler и REST API.
		3. ResponseStatusExceptionResolver - Разрешает исключения с аннотацией @ResponseStatus и сопоставляет их с кодами состояния HTTP на основе значения в аннотации.
		4. ExceptionHandlerExceptionResolver - Разрешает исключения путем вызова метода @ExceptionHandler в классе @Controller или @ControllerAdvice. Ознакомиться с методами @ExceptionHandler.	
			
	Можно создать цепочку исключений, создав несколько реализаций HandlerExceptionResolver и установив их свойство order. Чем выше значение свойства order, тем позже позиционируется звено исключения.  
	
	Если исключение остается неразрешенным - контейнер сервлета перенаправляет запрос по URL, настроенному по-умолчанию. 
	
	Пример в web.xml:
		<error-page>
			<location>/error</location>
		</error-page>
	
	Настройка обработки может быть осуществлена при помощи обычного контроллера.
			
	-----------------------------------------------------------------------------------		
	Разрешение просмотра (View Resolution)
	
	В Spring MVC есть интерфейсы ViewResolver и View, которые позволяют отображать модели в браузере, не привязывая вас к определенной технологии представления. ViewResolver обеспечивает сопоставление между именами представлений и фактическими представлениями. View относится к подготовке данных перед передачей определенной технологии просмотра.
	
	Реализации ViewResolver:
	
	1. AbstractCachingViewResolver - Подклассы экземпляров представления кэша AbstractCachingViewResolver. Кэширование повышает производительность некоторых технологий представления. Вы можете отключить кэш, установив для свойства cache значение false. Кроме того, если необходимо обновить определенное представление во время выполнения (например, при изменении шаблона FreeMarker), можно использовать метод removeFromCache(String viewName, Locale loc).
	2. XmlViewResolver - Реализация ViewResolver, которая принимает файл конфигурации, написанный в XML с тем же DTD, что и фабрики XML-компонентов Spring. Файл конфигурации по умолчанию - /WEB-INF / views.XML.
	3. ResourceBundleViewResolver - Реализация ViewResolver, который использует определения bean в ResourceBundle, заданном базовым именем пакета. Для каждого представления, которое он должен разрешить, он использует значение свойства [viewname].(class) как класс представления и значение свойства [viewname].url-адрес в качестве URL-адреса представления. Примеры можно найти в главе, посвященной технологиям просмотра.
	4. UrlBasedViewResolver - Простая реализация интерфейса ViewResolver, который влияет на прямое разрешение логических имен представлений в URL-адреса без явного определения сопоставления. Это уместно, если ваши логические имена совпадают с именами ресурсов представления простым способом, без необходимости произвольных сопоставлений.
	5. InternalResourceViewResolver - Удобный подкласс UrlBasedViewResolver, который поддерживает InternalResourceView (по сути, сервлеты и JSP) и подклассы, такие как JstlView и TilesView. Вы можете указать класс представления для всех представлений, созданных этим преобразователем, с помощью setViewClass(..). См. UrlBasedViewResolver javadoc.
	6. FreeMarkerViewResolver - Удобный подкласс UrlBasedViewResolver, который поддерживает FreeMarkerView и пользовательские подклассы из них
	7. ContentNegotiatingViewResolver - Реализация интерфейса ViewResolver, который разрешает представление на основе имени файла запроса или заголовка Accept. См. Content Negotiation.		
			
	
	Handling - обработка.	
			
	Интерфейс ViewResolver может возвращать значение null, если представление не найдено. Однако в случае JSP и InternalResourceViewResolver единственным способом выяснить, существует ли JSP, является выполнение отправки через RequestDispatcher. Поэтому необходимо всегда настраивать InternalResourceViewResolver, чтобы он был последним в общем порядке преобразователей представлений.		
			
			
	Redirecting - переадресация	
	
	Специальный префикс redirect: в имени View позволяет выполнять перенаправление. UrlBasedViewResolver (и его подклассы) распознают это как инструкцию о необходимости перенаправления. Остальная часть имени View - это URL-адрес перенаправления.

	Результат такой же, как если бы контроллер вернул RedirectView, но теперь сам контроллер может работать с точки зрения логических имен представлений. Логическое имя представления (например, redirect:/myapp/some/resource) перенаправляет по отношению к текущему контексту сервлета, в то время как имя, такое как redirect:https://myhost.com/some/arbitrary/path перенаправляет на абсолютный URL-адрес.
	
	
	Forwarding - Пересылка
	
	Можно использовать специальный префикс forward: для имен представлений, которые в конечном итоге разрешаются с помощью UrlBasedViewResolver и подклассов. Это создаст InternalResourceView, который выполнит RequestDispatcher.forward(). Поэтому этот префикс бесполезен при использовании InternalResourceViewResolver и InternalResourceView (для JSP), но он может быть полезен, если вы используете другую технологию представления, но все же хотите принудительно перенаправить ресурс, который будет обрабатываться механизмом Servlet/JSP. Обратите внимание, что вместо этого можно также связать несколько сопоставителей представлений.
	
	-----------------------------------------------------------------------------------
	LOCALE - локализация.
	
	Spring mvc поддерживает интернационализацию. DispatcherServlet позволяет автоматически сделать выбор в сторону языкового стандарта клиента. Это делается с помощью объектов LocaleResolver.
	
	Когда приходит запрос - DispatcherServlet ищет преобразователь языкового стандарта и, если он находит его - пытается использовать для установки локализации. С помощью RequestContext.getLocale(), вы всегда можете получить языковой стандарт, который был выбран преобразователем языкового стандарта.
	
	В дополнение к автоопределению локализации можно также добавить перехватчик к сопоставлени обработчика, чтобы изменить локализацию при определенных обстоятельствах (например, на основе параметра в запросе).
	
	Locale Interceptor - Перехватчик локализации 
	
	Вы можете включить изменение локалей, добавив LocaleChangeInterceptor в одно из определений HandlerMapping. Он находит параметр в запросе и соответственно изменяет языковой стандарт, вызывая метод setLocale на LocaleResolver в контексте приложения диспетчера.
	
	-----------------------------------------------------------------------------------
	MULTIPART RESOLVER - используется для загрузки файлов.
	
	MultipartResolver в пакете org.springframework.web.multipart - это механизм для разбора составных запросов, включая загрузку файлов. Существует 2 реализации - одна, основанная на Commons FileUpload, а другая - на анализе составных запросов Servlet 3.0.
	
	Чтобы включить многоэлементную обработку, необходимо объявить компонент MultipartResolver в конфигурации DispatcherServlet Spring с именем multipartResolver. DispatcherServlet найдет его и применяет к входящему запросу. Когда сообщение с типом содержимого multipart/form-data получено, преобразователь анализирует содержимое и обертывает текущий HttpServletRequest как MultipartHttpServletRequest, для обеспечения доступа к разрешенным частям в дополнение к предоставлению их в качестве параметров запроса.
	
	
	
	
	
2. Конфигурационный класс.
		
		Реализует интерфейс WebMvcConfigurer

	
	