Структура web приложения спринг:

	Спринг - фреймворк управления компонентами (Бинами). Все бины объединяются в контекст приложения. В Spring MVC cуществует 2 вида контекстов: Корневой и дочерний контаксты. Спринг может обновременно содержать несколько контекстов, один будет корневым, остальные дочерними. Все бины, объявленные в дочерних контекстах могут получить доступ к бинам корневого контекста, но не наоборот.
	
	1. ContextLoaderListener - данный класс создает корневой контекст приложения. Этот контекст может использоваться всеми Dispatcher Servlet-ами, существует только один экземпляр.
	2. DispatcherServlet - является сервлетом, основная цель которого - обрабатывать входящие http-запросы. Количество сервлетов в 1 приложении не органичено. Каждый сервлет имеет свой контекст (дочерний).
	
	При получении http запроса, DispatcherServlet, на основе анализа URL выбирает соответсвующий контроллер и представление, затем формируется ответ клиенту.
	
	
=================================================================================	
	А теперь рассмотрим подробнее:
	
	ServletContext - интерфейс, определяющий набор методов, которые сервлет использует для связи со своим контейнером сервлетов. Существует в единственном экземпляре на все веб приложение и JVM, которая его выполняет. Если в дисктипторе развертывания приложение помечено как "распределенное" - лучше не использовать ServletContext для обмена глабальными параметрами между JVM, поскольку контекст не будет глобальным. (на каждой jvm свой). ServletContext находится в объекте ServletConfig, который используется для передачи информации сервлету во время инициализации.
	
	Все начинается с интерфейса WebApplicationInitializer, который позволяет программно настроить ServletContext. Интерфейс WebApplicationInitializer содержит 1 метод - onStartup, который принимает объект, реализующий ServletContext. WebApplicationInitializer автоматически обнаруживается контейнером сервлетов.
	
	В методе onStartup(ServletContext servletContext){} мы можем (основные функции):
		
		1. Инициализировать корневой контекст (root-контекст). Этот контекст содержится в 1 экземпляре, конфигурация описывается в пользовательском классе, отмеченным аннотацией @Configuration
			Пример: 
				AnnotationConfigWebApplicationContext rootContext = new AnnotationConfigWebApplicationContext();
				rootContext.register(AppConfig.class)
			где 
				AnnotationConfigWebApplicationContext - класс, позволяющий регистрировать классы, отмеченные аннотацией @Configuration, @Component или совместимые с JSR-330
				AppConfig - пользовательский класс содержащий описания бинов, отмеченный @Configuration, @Component или совместимые с JSR-330.
	
		2. Добавить слушатель к ServletContext. Пример слушателя: ContextLoaderListener - Интерфейс для получения уведомлений об изменениях жизненного цикла ServletContext. Добавить слушателя можно методом addListener(...)    
			Пример использования:
				servletContext.addListener(new ContextLoaderListener(rootContext));
			где rootContext - экземпляр AnnotationConfigWebApplicationContext, или XmlConfigWebApplicationContext и т.п.
				
		3. Добавить фильтры - классы, реализующие интерфейсс Filter. Фильтры выполняют фильтрацию в методе doFilter. Каждый фильтр имеет доступ к объекту FilterConfig, из которого он может получить свои параметры инициализации и ссылку на ServletContext для выполнения фильтрации. Может использоваться для Аутентификации, лиггеризации и т.п.
			Пример использования:
				FilterRegistration charEncodingFilterReg = container.addFilter("CharacterEncodingFilter", CharacterEncodingFilter.class);
				charEncodingFilterReg.setInitParameter("encoding", "UTF-8");
				charEncodingFilterReg.setInitParameter("forceEncoding", "true");
				charEncodingFilterReg.addMappingForUrlPatterns(null, false, "/*");
		4. Добавить сервлет - объект, котрырй принимает http-запрос и выбирает соответсвующий контроллер и представление и возвращает ответ.
			Пример использования:
				ServletRegistration.Dynamic dispatcher = container.addServlet("dispatcher", new DispatcherServlet(dispatcherContext));
				dispatcher.setLoadOnStartup(1);
				dispatcher.addMapping("/");
			где:
				dispatcherContext - объект класса AnnotationConfigWebApplicationContext, в который передан классы, отмеченные аннотацией @Configuration, @Component или совместимые с JSR-330 с описанием кмпонентов для этого сервлета. 
		5. Устанавливать атрибуты 
			Пример:
				setAttribute(String name, Object object)
		и пр...
	
	
	Рассмотрим понятие контекста спринг. При получении описания (в xml или классе с аннотацией), спринг производит сканирование всех бинов, и начинает удовлетворять зависимости. Например, если одним из полей класса "а" будет класс "б", то спринг найдет и создаст экземпляр класса "б" и подставит его в поле класса "а", затем создаст класса "а" и поместит его в коллекцию бинов. Такое связывание называется DI - Dependency Injection. 
	
	В спринг применяется паттерн Factory, он позволяет создать объект через публичный статический метод. В спринг есть 2 варианта контейнеров: BeanFactory и ApplicationContext. BeanFactory - простой контейнер, который обеспечивает базовую поддержку DI. ApplicationContext - ресширяет интейрфейс BeanFactory и является более сложным контейнером, который помимо DI , предлагает возможность автоматической регистрации BeanPostProcessor, BeanFactoryPostProcessor и т.п. Контекст в спринг создается реализациями интерфейса ApplicationContext. Реализаций достаточно много, как правило они отличаются источником, где располагается описание компонентов (бинов). Я использовал XmlWebApplicationContext, AnnotationConfigApplicationContext и AnnotationConfigWebApplicationContext. 
	
	Рассмотрим описание бинов при помощи Java-класса и аннотаций. Для использования такого способа описания бинов мы должны выбрать класс AnnotationConfigWebApplicationContext, в который при помощи метода register(<class>) передаем класс конфигурации. 
	
	Рассмотрим подробнее класс конфигурации:
	Класс конфигурации - обычный класс, отмеченный аннотацией @Configuration. Если мы хотим объявить бин - нужно создать метод, отметить его аннотацией @Bean или @Component, возвращаемое значение которого и будет экземпляром бина. По умолчанию, все бины являются синглтонами, но это можно изменить, указав аннотацию @Scope(value = "<значение>")
		значением может быть singleton, prototype, request, session, global-session
	 
	Интерфейс WebMvcConfigurer, который опрелеляет методы обратного вызова для настройки конфигурации на основе Java. При использовании аннотации @EnableWebMvc конфигурация будет настрена по-умолчанию.
	Помимо простых бинов мы можем сконфигурировать некоторые параметры контекста самостоятельно. Рассмотрим основные методы более подробно:
		1. addArgumentResolvers(...) - добавляет обработчик для поддержки пользовательских типов аргументов.
		2. addFormatters(...) - добавляет конвертеры и Форматтеры в дополнение к тем, которые зарегистрированы по умолчанию.
		3. addInterceptors(...) - добавляет перехватчики вызовов методов контроллера.
		4. addResourceHandlers(...) - добавляет обработчики для обработки статических ресурсов (изображений, js и css-файлов в корневом каталоге веб-приложения).
		5. addReturnValueHandlers(...) - добавляет обработчики для поддержки типов возвращаемых значений методов контроллера.
		6. configureAsyncSupport(...) - Настройка параметров асинхронной обработки запросов.
		7. configureHandlerExceptionResolvers(...) - Настройка преобразователей исключений.
		8. extendHandlerExceptionResolvers(...) - Расширение или изменение списка преобразователей исключений, настроенных по умолчанию.
		9. configureViewResolvers(...) - Настройка сопоставления для преобразования строковых имен представлений, возвращаемых контроллерами, в конкретные реализации представлений для выполнения визуализации. Использовал этот метод для реализации ответа контроллера в формате JSON.
	Так же полезная аннотация - ComponentScan. Она позволяет выполнять сканирование пакетов на наличие классов, отмеченных аннотациями @Component и производных от них. Соответвенно благодаря этой аннотации мы можем не добавлять нащи бины в класс который будет передан в ApplicationContext, а просто расставить аннотации в коде и указать в свойствах аннотации путь к пакету с этим классом. В этом случае спринг так же найдет  бин и зарегитрирует его.	
		
	Рассмотрим подробнее контроллеры в spring:	
	Контроллер - бин, выполняющий обработку http запроса и подготовку ответа клиенту. Отмечается анннотацией @Controller. Эта аннотация говорит о том, что класс работает как HttpServlet, но с расширенными возможностями от спринг. Так же может быть отмечен аннотацией @RestController которая объединяет поведение двух аннотаций @Controller и @ResponseBody. @ResponseBody - Аннотация показывает что данный метод может возвращать кастомный объект в виде xml, json и т.п.
	Поскольку контроллеры работают с http запросами, мы должны указать конроллеру, какие именно запросы он должен обработать. Это можно сделать при помощи аннотации @RequestMapping, в качестве параметра которой мы можем передать часть URL, по которому будет выполнено сопоставления. Так же мы можем указать параметр method. Этот параметр указывает на тип запроса (GET, POST, PUT, DELETE, PATCH), которые будет обрабатывать наш контроллер. Если параметр не указывать - контроллер будет принимать все типы запросов.
	Если контроллер был отмечен аннотацией @RestController - для методов мы можен использовать аннотации @GetMapping, @PostMapping и т.п. Такие аннотации привязывают методы контроллера к определенному типу запроса.
	Get-запросы могут содержать параметры. Их значения можно передать в виде аргументов метода при помощи аннотации public 
		Пример http-запроса:
			http://localhost:8080/api/foos?id=123e4567e89b	
		Пример объявления метода контроллера:
			@GetMapping("/")
			String setupForm(@RequestParam("id") int id, Model model) {...}
	Иногда параметры http запроса можно будет передать контроллеру не ввиде get-параметров, а как часть URL. В этом случае нам поможет аннотация @PathVariable - которая распарсит URL и нужное нам значение передаст в качестве входящего аргумента нашего метода.
		Пример http-запроса:
			http://localhost:8080/api/foos/123e4567e89b	
		Пример объявления метода:
			@GetMapping("/{id}")
			public Person getPerson(@PathVariable Long id) {
				// ...
			}
	Есть прочие полезные аннотации, но писать я их конечно не буду.
	
	