
	EJB Session Beans;
		EJB 2 vs EJB 3
			- Более простой процесс поиска в EJB 3, чем в EJB 2. В EJB 2, разработчик должен определить зерен, реализованные интерфейсы (дом/местное/дистанционное/бизнес/...), который продлен интерфейсы EJB (EJBHome/EJBLocalHome/EJBObject/EJBLocalObject)... и что подразумевается, чтобы управлять техническими EJB в исключения, чтобы определить методы жизненного цикла, чтобы обеспечить выполнение обратных вызовов, чтобы помочь EJB-контейнером, чтобы вызвать бобы события жизненного цикла правильно. Короче говоря, это действительно использовалось, чтобы отвлечь внимание devoloper от бизнеса для реализации и привлечения технических сторон технологии. В EJB 3 боб является POJO и должен реализовать не более одного локального/удаленного интерфейса, который также является POJO. Кто еще хочет изучить EJB 2? Я не хочу! Совсем. Совсем.
			- Введение аннотаций в EJB 3, что делает жизнь проще для разработчика. И мы больше не обязаны определять наши бобы в XML-файле ejb-jar.XML
			- EJB 3 убил Entity Beans для доступа к данным, которые были шаблонными путем реализации интерфейса javax.EJB-компонента.EntityBean и принуждает разработчика обеспечить реализацию для многих методов: ejbLoad, ejbStore, ejbActivate и ejbPassivate... и воплотил в жизнь спецификацию JPA. Спецификация JPA не привязана к EJB 3. Но это просто так легко ввести JPA Entity Manager в контейнер EJB.
			- EJB 3 имеет лучшую производительность, чем EJB 2, поскольку контейнер не должен выполнять обратные вызовы, такие как ejbActive, ejbStore,…
		
		So what is typical about Session Beans?
			Сеансовые компоненты - это компоненты на стороне сервера, которые предоставляют представление для вызова клиентом, что означает, что сеансовый компонент не будет выполнять действие, если клиент не отправит запрос.

			Сеансовый компонент не доступен напрямую, но он имеет экземпляры, развернутые в контейнере EJB (WildFly в нашем случае). Таким образом, запрос клиента отправляется на своего рода прокси (представление), который, в свою очередь, делегирует обработку запроса клиента контейнеру EJB, и это зависит от контейнера EJB, чтобы выбрать правильный экземпляр SB для выполнения задания.
			
			Существует 3 типа сеансовых бобов :
				1. Сеансовые Компоненты Без Сохранения Состояния
				2. Сеансовые Компоненты С Отслеживанием Состояния
				3. Синглтон Бобы
			
			Stateless Session Beans (SLSB)
				Представьте, что у вас есть коробка, в которой есть дюжина синих ручек, бесконечных чернил *genius*.
				Всякий раз, когда вам нужно записать слово, вы закрываете глаза, а затем берете любую синюю ручку из коробки. Вы используете ручку, чтобы записать слово, а затем положить его обратно в коробку.
				Будучи бесконечными чернилами, вы теоретически не изменили состояние любого синего пера. И что касается цели синей ручки, которая производит синий рукописный сценарий, любая ручка может делать то же самое!
				И так это же самое для Боба без гражданства. Контейнер EJB будет иметь пул Stateles SB. И в соответствии с внутренним алгоритмом выбора контейнера, клиент может получить любой экземпляр SB без состояния.
					Аннотация : @Stateless
					Мой рекомендуемый способ получить SLSB: Injection.
			Сеансовые компоненты с отслеживанием состояния (SFSB)
				Я дал тебе печенье. Ты ел из печенья.
				Доверьтесь мне. Вы изменили состояния печенья, так как объем файла был уменьшен. И поэтому, объединение не допускается.
				Кроме того, мы действительно не можем есть одно и то же печенье одновременно, если вам нравится делиться. И если я приму твое предложение, мне придется ждать, пока ты перестанешь есть печенье! Многие люди могут попросить съесть одно и то же печенье, но мы не можем съесть его все вместе в одно и то же время.
				Что было бы интересно, это дать каждому из нас печенье. Тогда каждая информация cookie будет привязана к потребителю: cookie.eatenVolume, cookie.eatingSpentTime, cookie.tasteRate, cookie.textureRate...
				Технически говоря, сеансовые компоненты с отслеживанием состояния поддерживают разговорное состояние и предназначены для одного клиента. Но только один клиент одновременно может использовать компонент сеанса с отслеживанием состояния, поскольку SFSBs не являются многопоточными. SFSB может обрабатывать параллельные запросы. Однако эти вызовы фактически не обращаются к компоненту одновременно.
				Обычно мы выбираем компонент сеанса с отслеживанием состояния, когда нам действительно нужно привязать состояние объекта к клиенту. Однако вы должны иметь в виду, что SFSB не контекстуализируется. Представьте, что вы получаете SFSB в течение сеанса HTTP. Не ожидайте, что контейнер освободит SFSB после истечения срока действия сеанса HTTP. Вы несете ответственность за свой SFSB, и вы должны уничтожить его программно. Таким образом, вы можете поместить слушателя на свой сеанс, а затем уничтожить SFBS, когда ваш сеанс истекает.
					Аннотация: @Stateful
					Мой рекомендуемый способ получить SLSB: JNDI lookup.
			Singleton Beans
				Вместо реализации Одноэлементного шаблона проектирования можно создать одноэлементный компонент в двух словах.
				Всякий раз, когда у вас есть ограничение на создание одного экземпляра, вы можете объявить его как синглтон. Таким образом, даже если у вас было распределенное приложение, каждый модуль будет иметь доступ к одному и тому же экземпляру.
				Синглтон является многопоточным. Таким образом, параллельный доступ возможен. Синглтон также может поддерживать состояние, и поэтому мы можем изменять атрибуты экземпляра. Чтобы избежать проблем параллелизма, старайтесь управлять им, например, с помощью ключевого слова synchronized.
				Одноэлементная инициализация может быть нетерпеливой, поскольку она может быть ленивой.	
					Ленивая инициализация: синглтон будет инициализирован при первом вызове.
					Нетерпеливая инициализация: синглтон будет инициализирован при развертывании с помощью аннотации: @Startup
					Аннотация : @Singleton
					Мой рекомендуемый способ получить SFSB: Injection
					
					
					
					
					