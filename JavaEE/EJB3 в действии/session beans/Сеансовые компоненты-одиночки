	
	Общий принцип работы:
		Компоненты-одиночки близко напоминают компоненты без сохранения состояния. Они поддерживают обработку тех же событий жизненного цикла, но имеют и свои, уникальные особенности, включая возможность управления параллельным доступом, а также возможность определять цепочки для создания компонентоводиночек в определенной последовательности. Поддержка таких цепочек позволяет одним компонентам зависеть от других. Как уже упоминалось, компоненты одиночки можно пометить, чтобы обеспечить их создание на этапе развертывания приложения. В этом случае запуск приложения не будет считаться выполненным, пока все отмеченные компоненты не будут успешно созданы.
	
	Когда следует использовать сеансовые компоненты-одиночки:
		Компоненты-одиночки используются, когда требуется иметь некоторое общее состояние, глобальное для всего приложения или для определенной задачи.
		
	Когда не нужно использовать компоненты-одиночки
		1. Никогда не используйте компоненты-одиночки для реализации служб без сохранения состояния – вместо этого пользуйтесь сеансовыми компонентами без сохранения состояния.

	Аннотации уровня класса
		@Singleton					- Пометить как сеансовый компонент-одиночку
		@Startup					- говорит контейнеру, что компонент должен быть создан на этапе запуска приложения.
		@DependsOn("A", "B") 		- Определяет зависимость компонента от других компонентов. Порядок следования зависимостей в списке не определяет порядок создания компонентов. Для этого компонент B сам должен быть отмечен аннотацией @DependsOn с именем компонента A.
		
	Аннотации уровня методов		
		@Schedule(dayOfMonth=”*”,dayOfWeek=”*”,hour=”0”,minute=”0”,second=”0”) - Запланировать обновление товара дня кажду полночь (метод будет вызываться по расписанию)
		@PostConstruct – метод, отмеченный этой аннотацией, будет вызываться сразу после создания экземпляра и внедрения всех ресурсов, но до доступности компонента для вызова;
		@PreDestroy – метод, отмеченный этой аннотацией, будет вызываться непосредственно перед уничтожением экземпляра.
	
	Управление конкуренцией
		Существует две разновидности поддержки конкуренции:
			- на уровне контейнера (@ConcurrencyManagement(ConcurrencyManagementType.CONTAINER))
					По умолчанию (если не указано иное) управление конкуренцией осуществляется на уровне контейнера.  В этом случае синхронизация вызовов методов выполняется самим контейнером. Аннотации, предназначенные для этой цели, позволяют помечать методы как доступные для чтения или записи, а также определять таймаут для методов, которые способны блокировать выполнение.
					По умолчанию доступ ко всем методам компонента упорядочивается посредством блокировок для записи. В спецификации EJB определяется две аннотации, с помощью которых можно сообщить контейнеру о желаемом поведении блокировки:
						@Lock (LockType.READ) 		– метод, отмеченный этой аннотацией будет одновременно доступен множеству клиентов, пока кто-то не приобретет блокировку для записи;
						@Lock(LockType.WRITE) 		– при вызове метода будет устанавливаться блокировка для записи, поэтому метод всегда будет выполняться только в контексте одного потока. Эта аннотация будет применена, если не явно не указана ни одно из аннотаций. 
					Эти аннотации можно применять к методам и в прикладном интерфейсе, и в самом классе компонента.
			- на уровне компонента (@ConcurrencyManagement (ConcurrencyManagementType.BEAN)). 
					Для реализации управления конкуренцией на уровне компонента можно использовать стандартные средства языка Java: synchronized, volatile или java.util.*
						
			@ConcurrencyManagement должна помещаться в определение класса компонента, а не в прикладной интерфейс:
			
			@AccessTimeout(value=1, unit=TimeUnit.MINUTES) - аннотация служит для определения величины таймаута. Так как вызов метода компонента-одиночки может привести к блокировке вызывающего кода, предусмотрен механизм разблокировки по таймауту, чтобы исключить возможность блокировки навечно. По истечении таймаута возбуждается исключение javax.ejb.ConcurrentAccessTimeoutException. Это исключение времени выполнения, соответственно вызывающий код не сможет перехватить его. В качестве агрументов аннотации можно указать продолжительность таймаута и единицу измерения. В качестве единиц измерения можно указать наносекунды, микросекунды, миллисекунды, секунды, минуты, часы, дни.
	
	Прикладной интерфейс компонента
		Сеансовые компоненты-одиночки поддерживает те же возможности для прикладных интерфейсов, что и сеансовые компоненты без сохранения состояния. Можно определять удаленные и локальные интерфейсы, а также интерфейсы веб-служб (SOAP и REST) с помощью аннотаций @Local, @Remote или @WebService, соответственно.  Отличие одиночек от компонентов без сохранения состояния - возможность использования аннотаций к методам @Lock (LockType.READ), @Lock(LockType.WRITE), @AccessTimeout. Эти аннотации работают только при упралении конкуренцией, чего в компонентах без сохранения состояни быть не может.
	
	События жизненного цикла
		1. Контейнер создает новый экземпляр компонента-одиночки на этапе запуска приложения, если этот компонент помечен аннотацией @Startup или указан в виде зависимости (@DependsOn) другого компонента. Обычно создание компонентов-одиночек откладывается до момента первого обращения к ним.
		2. Когда конструктор компонента завершится, контейнер внедряет ресурсы, такие как контексты JPA, источники данных и другие компоненты.
		3. Вызывается метод, отмеченный аннотацией @PostConstruct. Компонент остается недоступным, пока этот метод не завершится успехом.
		4. Экземпляр компонента хранится в памяти, ожидая обращений к его методам.
		5. Клиент вызывает прикладной метод посредством прикладного интерфейса.
		6. Контейнер информируется, что он должен прекратить работу.
		7. Перед завершением он вызывает метод компонента, отмеченный аннотацией @PreDestroy
			
	Эффективное использование сеансовых компонентов-одиночек:
		1. Выбор типа конкуренции - Управление конкуренцией на уровне контейнера является наиболее предпочтительным для подавляющего большинства компонентов.  Данный подход имеет смысл применять, только если действительно необходимо организовать более тонкое управление блокировками. Однако, если данные хранятся в объекте HashMap, обладающем поддержкой многопоточного доступа, вам не нужно задумываться о выборе механизма управления конкуренцией.
		2.  Метод, осуществляющий запись, изменяет данные и потому должен выполняться под защитой исключительной блокировки. Метод, осуществляющий чтение, не требует такой строгой меры и может одновременно обслуживать множество клиентов.
		3. Исключение, сгенерированное в методе компонента-одиночки, отмеченном аннотацией @PostConstruct, вызывает уничтожение экземпляра. Если метод @PostConstruct, возбудивший исключение, принадлежит компоненту с автозапуском, сервер приложений может отказаться от развертывания приложения. 