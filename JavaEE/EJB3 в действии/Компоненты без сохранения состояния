
	КОМПОНЕНТЫ БЕЗ СОХРАНЕНИЯ СОСТОЯНИЯ

---------------------------------------------------------------------------	
	Прикладные интерфейсы компонентов:
		есть 3 способа использовать сеансовые компоненты без сохранения состояния:
			1. через локальный интерфейс, внутри той же виртуальной машины JVM.
			2. через удаленный интерфейс с использованием механизма RMI.
			3. посредством веб-службы SOAP или REST.
	
		Поддержка этих трех методов доступа к компоненту включается с помощью аннотаций. Каждая аннотация должна быть помещена перед интерфейсом, реализуемым компонентом.
		
		ЛОКАЛЬНЫЙ ИНТЕЙРФЕЙС:
			Локальный интерфейс предназначен для использования клиентами, находящимися в том же экземпляре контейнера (JVM). Обозначается аннотацией @Local. Является аннотацией по-умолчанию, т.е. если не указать аннотацию явно, она будет автоматически установлена для интерфейса. Начиная с EJB3.1 интерфейсы вообше не обязательно создавать. Если класс помечен аннотацией сеансового компонента, к нему вы сможете получить доступ путем внедрения экземпляра класса. Если интерфейс не объявлен явно, все метода класса будут доступны. (? Проверить. Наверняка только public методы).
		
		УДАЛЕННЫЙ ИНТЕРФЕЙС.
			
			Клиенты, находящиеся за пределами виртуальной машины JVM, где выполняется экземпляр контейнера, должны использовать некоторую разновидность удаленного интерфейса. Если клиент так же написан на Java, наиболее логичным выглядит выбор RMI – удаленного интерфейса доступа к компонентам EJB. RMI – высокоэффективный API, основанный на использовании протокола TCP/IP. От удаленных прикладных методов не требуется, чтобы они возбуждали исключение java.rmi.RemoteException и все их параметры должны поддерживать интерфейс Serializable, т.е. обязательное наличие аннотации не требуется.
		
		ИНТЕРФЕЙС КОНЕЧНОЙ ВЕБ-СЛУЖБЫ.
			В Java EE 7 поддерживается две различные технологии организации веб-служб: 
				1. SOAP, посредством JAX-WS
				2. REST, посредством JAX-RS 
				В обоих случаях соответствующие аннотации могут быть помещены либо перед отдельным интерфейсом, либо непосредственно перед классом компонента.
			Чтобы экспортировать существующий компонент в виде веб-службы, достаточно просто создать новый экземпляр и добавить аннотацию @javax.jws.WebService При использовании этой аннотации с интерфейсом, для REST-сервиса извне будут доступны только те методы, которые определены интерфейсом, однако, для локального и удаленного доступа будут доступны и остальные методы класса.
			
			
			Пример REST-службы:								

				@Stateless
					// Пометить сеансовый компонент без сохранения состояния как
					// экспортируемый через REST с корневым URI /bid
				@Path(“/bid”)
				public class BidRestService {
					@EJB
					private BidService bidService;
					...
					
						// При получении запроса HTTP GET будет вызван метод getBid
					@GET
						// Метод getBid должен вернуть объект ставки в формате XML
					@Produces(“text/xml”)
						// Идентификатор ставки извлекается из параметра HTTP-запроса
					public Bid getBid(@QueryParam(“id”) Long id) {
						return bidService.getBid(id);
					}
					...
						// При получении запроса HTTP DELETE будет вызван метод deleteBid
					@DELETE
					public void deleteBid(@QueryParam(“id”) Long id) {
						Bid bid = bidService.getBid(id);
						bidService.deleteBid(bid);
					}
				}
		
				Веб-служба REST вызывается обращением по адресу http://<hostname>:<port>/actionbazaar/rest/bid. Параметры запроса передаются по мере необходимости. Например, адрес URL для извлечения информации о ставке имеет вид: http://<hostname>:<port>/actionbazaar/rest/bid?id=1010.
		
	
	
---------------------------------------------------------------------------	
	События жизненного цикла	

		Сеансовые компоненты без сохранения состояния имеют очень простой жизненный цикл – они либо существуют, либо нет. Сразу после создания компонент помещается в пул, в ожидании появления запросов от клиента. В конечном итоге компонент уничтожается, либо когда нагрузка на сервер уменьшается, либо когда завершается само приложение. 
		
		Порядок действий контейнера:
			1. Создает экземпляр компонента вызовом конструктора по умолчанию.
			2. Внедряет ресурсы, такие как провайдеры JPA и соединения с базами данных.
			3. Помещает экземпляр компонента в управляемый пул (если поддерживается).
			4. Когда от клиента поступает запрос, извлекает простаивающий компонент из пула. В этот момент контейнер может создавать дополнительные компоненты для обработки запросов. Если контейнер не поддерживает пулы, он просто создает экземпляр компонента.
			5. Вызывает запрошенный метод посредством прикладного интерфейса.
			6. Когда метод вернет управление, компонент помещается обратно в пул (если поддерживается). Если контейнер не поддерживает пулы, он просто уничтожает компонент.
			7. При необходимости контейнер удаляет из пула ненужные компоненты.
	
	
---------------------------------------------------------------------------
	Эффективное использование сеансовых компонентов без сохранения состояния
		1. Настраивайте пул под свои нужды
		2. Не злоупотребляйте поддержкой удаленного доступа (Проблема в том, что если по ошибке использовать аннотацию @Remote вместо @Local, локальные компоненты EJB будут внедряться аннотацией @EJB как удаленные)
		3. Используйте интерфейсы
		4. Особое внимание уделяйте проектированию удаленных интерфейсов. Можно иметь локальный и удаленный интерфейсы, экспортирующие совершенно разные наборы методов.
		5. Удаленные объекты не должны передаваться по ссылке. Параметры и возвращаемые значения удаленных методов должны поддерживать сериализацию. Кроме того, передача объектов по сети осуществляется их копированием (сответственно, при уделенном изменении объекта локальная ссылка измененена не будет.)
		6. Избегайте слишком мелкого дробления удаленных вызовов, поскольку удаленный вызов - дорогостоящая операция. (Например, в пользовательском интерфейсе нужно предусмотреть возможность отмены сразу нескольких ставок - нет смысла вызывать метод BidService.cancel() в цикле – это было бы очень неэффективно. Вместо этого следует добавить дополнительный метод, который будет принимать список ставок для отмены.)
		
		
---------------------------------------------------------------------------
	Аннотации:
		
		@Stateless - превращает POJO в сеансовый компонент без сохранения состояния. Имеет 3 параметра: 
			1. name -  определяет имя компонента, используется контейнером для включения компонента в глобальное дерево JNDI. Если параметр не установлен - компоненту будет присвоено имя класса.
			2. mappedName - используется некоторыми контейнерами как имя компонента. Использование нежелательно.
			3. description - 
		
		@Resource - используется для внедрения источника данных JDBC.
		@Remote - определяет интерфейс удаленных взаимодействий (на случай обслуживания удаленных клиентов). Использует технологию RMI. 
		@PostConstruct - метод, отмеченный этой аннотацией, будет вызываться сразу после создания экземпляра и внедрения всех ресурсов
		@PreDestroy - метод, отмеченный этой аннотацией, будет вызываться непосредственно перед уничтожением экземпляра (перед удалением компонента из пула).
		@Stateless		|	помечает сеансовый компонент как экспортируемы через REST
		@Path(“/bid”)	|		c корневым URI /bid
		@GET	- тмп HTTP-запроса (возможны @POST, @PUT, @DELETE, @PATCH, @GET)
		@Produces(“text/xml”) - формат возвращаемого значения.
		public Bid getBid(@QueryParam(“id”) Long id) {} - извлечение из параметра HTTP-запроса
		@WebService - экспортирует существующий компонент в виде веб-службы.