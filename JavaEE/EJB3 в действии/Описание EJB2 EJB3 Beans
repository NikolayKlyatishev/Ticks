
	Определение EJB, Beans

		EJB2 - спецификация (документ, утвержденный как стандарт, описывающий все аспекты технологии). Бины определяются  в файле ejb-jar.XML
		EJB3 - спецификация (документ, утвержденный как стандарт, описывающий все аспекты технологии). определяются при помощи аннотаций. 
		
	Отличия EJB2 и EJB3
		1. В EJB3 более простой процесс поиска, чем в EJB 2. В EJB 2 разработчик должен был определить бины, реализующие интерфейсы (home/local/remote/business/...), которые расширили интерфейсы EJB (EJBHome/EJBLocalHome/EJBObject/EJBLocalObject)..., и это означает управление исключениями EJB, определение методов жизненного цикла, предоставление реализации обратных вызовов, для корректной инциализации контейнером EJB событий жизненного цикла бинов. Это заставляло разработчика сосредоточиться не на бизнес-логике, а на технической реализации технологических особенностей фреймворка. В EJB 3 бин является POJO и должен реализовать не более одного локального/удаленного интерфейса, который также является POJO.
		2. Введение аннотаций в EJB3, делает жизнь разработчика проще. Больше не нудно определять бины в XML-файле ejb-jar.XML.
		3. EJB3 заменил бины доступа к данным, на спецификацию JPA. Спецификация JPA не привязана к EJB3. Все, что нужно сделать - ввести JPA Entity Manager в контейнер EJB.
		4. EJB3 гораздо более производителен, чем EJB2, так как контейнер не должен выполнять обратные вызовы, такие как ejbActive, ejbStore,…
	
	Enterprise JavaBeans	
		Enterprise JavaBeans (также часто употребляется в виде аббревиатуры EJB) — спецификация технологии написания и поддержки серверных компонентов, содержащих бизнес-логику. Является частью Java EE.
		
		Каждый EJB-компонент является набором Java-классов со строго регламентированными правилами именования методов (верно для EJB 2.0, в EJB 3.0 за счет использования аннотаций выбор имён свободный). 
		EJB бывают трёх основных типов:
		
	Entity Bean	
		Entity Bean - это сущности каких-то объектов и в EJB они являются хранилищем данных на период жизненного цикла Entity. Работа с entity была описана в спецификации JPA.
		Спецификация JPA определяет стандарт для:
			1. Конфигурации маппинга сущностей приложения и их отображения в таблицах БД;
			2. EntityManager API – позволяет выполнять CRUD (create, read, update, delete) операции над сущностями;
			3. Java Persistence Query Language (JPQL) – для поиска и получения данных приложения.
	
		Entity - persistent domain object - основная сущность, которой манипулирует программа (объект бизнес логики), например в приложении управления заметками - заметка будет сущностью.
		Требования JPA к классам бизнес логики:
			1. Entity класс должен быть отмечен аннотацией @Entity или описан в xml файле конфигурации JPA.				
			2. Entity класс должен содержать public или protected конструктор без аргументов. (так же может содержать и конструкторы с аргументами, их наличие не обязательно).
			3. Entity класс должен быть классом верхнего уровня.
			4. Entity класс не может быть Enum или Интерфейсом
			5. Entity класс не может быть final-классом.
			6. Entity класс не может содержать final поля или методы в случае, если он участвует в маппинге.
			7. Если объект Entity будет передаваться по значению как отдельный объект, например через удаленный интерфейс - он должен реализовывать интерфейс Serializable.
			8. Поля Entity класса должны быть private и содержать getter и setter.
			9. Entity класс должен содержать первичный ключ, т.е. атрибут или группу атрибутов, по которым можно однозначено идентифицировать запись этого Entity в базе данных.
	
	EJB-компонент		
		EJB - спецификация технологии написания и поддержки серверных компонентов, содержащих бизнес-логику. 
		
		EJB распознает 2 типа компонентов:
			1. Session bean - сеансовые компоненты, развернутые в контейнере EJB. Таким образом, запрос клиента отправляется на своего рода прокси, который, в свою очередь, делегирует обработку запроса клиента контейнеру EJB. Выбор правильного экземпляра session bean зависит от контейнера. Экземпляр такого компонента доступен только пока выполняется некоторая единица работы и безвозвратно уничтожается в случае аварии или остановки сервера. Может реализовать любую прикладную логику. Сеансовые компоненты могут вызываться локально или удаленно, посредством Java RMI. Компоненты-одиночки и компоненты без сохранения состояния могут также экспортироваться в виде веб-служб SOAP и REST.			
				- statless session beans (без сохранения состояния). Такой компонент не хранит никакой информации о своем состоянии и представляет прикладные службы, которые выполняют все необходимые действия в рамках единственного запроса. Примерами компонентов без сохранения состояния могут быть реализации таких операций, как перевод средств на кредитную карту или проверка кредитной истории клиента.
				- stateful session beans (с сохранением состояния). Такой компонент автоматически сохраняет свое состояние между обращениями к нему от одного и того же клиента. Типичным примером компонента с сохранением состояния может служить корзина с покупками в интернет-магазине.  Сеансовые компоненты с сохранением состояния завершают свое существование либо по таймауту, либо по явному запросу клиента.
				- singleton. Такой компонент хранит информацию о своем состоянии, они совместно используется всеми клиентами и продолжает свое существование на протяжении всего времени работы приложения. Примером использования может быть использование скидки в интернет магазине, т.к. правила применения скидки как правило фиксированы и распространяются на всех клиентов. Это компонент бюл впервые добавлен в версии EJB 3.1
			2. message-driven beans - компоненты, управляемые сообщениями. Эти компоненты так же реализуют некоторую прикладную логику, но имеют одно важное отличие от Session bean: клиенты никогда не вызывают методы MDB непосредственно. Вместо этого компоненты MDB вызываются для обработки сообщений, отправленных на сервер сообщений, что открывает возможность организовать асинхронный обмен сообщениями между частями системы. В качестве примера сообщения можно привести запрос на пополнение товарных запасов от автоматизированной системы розничной торговли к системе управления поставками.
		
			Подобное деление на Session bean (statless session beans, stateful session beans, singleton) и message-driven beans выполнено для того, чтобы избежать перегрузки их слишком большим количеством служб.
			
			Основные аннотации EJB3:
				- @EJB – помечается bean, который мы собираемся использовать.
				- @Stateless – говорит контейнеру, что класс будет stateless session bean. Для него контейнер обеспечит безопасность потоков и менеджмент транзакций.
				- @Local – относится к интерфейсу и говорит, что bean реализующий интерфейс доступен локально.
				- @Remote – относится к интерфейсу и говорит, что bean доступен через RMI (Remote Method Invocation).
				- @Stateful – говорит контейнеру, что класс будет stateful session bean.
				- @Remove – метод, помеченный как Remove говорит контейнеру, что после его исполнения нет больше смысла хранить bean, т.е. его состояние сбрасывается. Это бывает критично для производительности.
				- @Entity – говорит контейнеру, что класс будет сущностью БД.
				- @Table(name=”<name>”) – указывает таблицу для маппинга БД.
				- @Id – указывает уникальный идентификатор сущности который будет ключом в БД.
				- @Column – указывает параметры колонки в БД включая имя колонки в БД.
				- @WebService – говорит, что интерфейс или класс будет представлять web-сервис.
			
			Правила создания session bean
				В качестве session bean может выступать обычный класс Java, но он должен удовлетворять следующим условиям:

				1. Он должен иметь как минимум один метод;
				2. Он не должен быть абстрактным;
				3. Он должен иметь конструктор по-умолчанию;
				4. Методы не должны начинаться с “ejb” (например ejbBean, ejbGoAtHome)
				5. Свойства класса должны быть объявлены примитивами или реализовывать интерфейс Serializable
			
			Перехватываемые события жизненного цикла бина:
				У stateless и MDB бинов существует 2 события жизненного цикла, которые мы можем перехватить. Это создание и удаление бина. Метод, который будет вызываться сразу после создании бина помечается аннотацией @PostConstruct, а перед его удалением – @PreDestroy.

				Stateful бины обладают помимо рассмотреных выше еще 2 событиями:
					1) При активации @PostActivate;
					2) При деактивации @PrePassivate
	Session bean.
		Session beans - сессионные бины - это серверные компоненты,который работают только в случае получения запроса от клиента.
		сессионные бины не доступен напрямую, но он имеет экземпляры, развернутые в контейнере EJB. Таким образом, запрос клиента отправляется на своего рода прокси, который, в свою очередь, делегирует обработку запроса клиента контейнеру EJB. Выбор правильного экземпляра session bean зависит от контейнера.
		
		Сессионные бины бывают 3 видов:
			1. Stateless session beans - бины без сохранения состояния.
				Аннотация: @Stateless
				Рекоммендуемый способ получения SLSB: Injection.
			2. Stateful Session beans - бины с отслеживанием состояния.		
				Аннотация: @Stateful
				Рекоммендуемый способ получения SLSB: JNDI поиск.
			3. Singleton beans - бины синглтоны.
				Аннотация: @Singleton
				Рекоммендуемый способ получения SLSB: Injection.				
	Message Driven Beans — их логика является реакцией на события в системе, позволяет JavaEE обрабатывать события асинхронно.
	
	Список используемых аннотаций EJB