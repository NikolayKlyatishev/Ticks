
Определение EJB, Beans

	EJB2 - спецификация (документ, утвержденный как стандарт, описывающий все аспекты технологии). Бины определяются  в файле ejb-jar.XML
	EJB3 - спецификация (документ, утвержденный как стандарт, описывающий все аспекты технологии). определяются при помощи аннотаций. 
	JPA - технология, обеспечивающая объектно-реляционное отображение POJO и предоставляющая API для получения и управления такими объектами. Спецификация JPA является частью спецификации EJB3. Сама JPA ничего не умеет делать сама, а лишь описывает принцип работы провайдеров. JPA описывает интерфейсы, которые должный быть реализованы. Так же в спецификации JPA описываются метаданные отображения и порядок работы провайдеров. В итоге провайдер, реализуя интерфейсы JPA, обеспечивает получение, сохранение и управление объектами. Существует несколько провайдеров, реулизующих интерфейсы JPA: Hibernate, Oracle TopLink, Apache OpenJPA.
	
	JPA состоит из 3 основных частей:
		1. API - интерфейсы пакета javax.persistance - набор интерфейсов, которые позволяют организовывать взаимодействие с провайдером.
		2. JPQL - объектный язык запросов. Отличие от sql заключается в том, что запросы sql строятся к таблицам и их колонкам, а в JPQL запросы строятся к именам классов и их атрибутам. В качестве параметров запросов используется типы данных атрибутов.
		3. Metadata - аннотации над объектами. Анализирую установленные над объектами аннотации JPA поймет какой объект в какую таблицу нужно сохранить. Описание метаданные можно при помощи xml и при помощи аннотаций.
		
	
	
	
	
	Отличия EJB2 и EJB3
		1. В EJB3 более простой процесс поиска, чем в EJB 2. В EJB 2 разработчик должен был определить бины, реализующие интерфейсы (home/local/remote/business/...), которые расширили интерфейсы EJB (EJBHome/EJBLocalHome/EJBObject/EJBLocalObject)..., и это означает управление исключениями EJB, определение методов жизненного цикла, предоставление реализации обратных вызовов, для корректной инциализации контейнером EJB событий жизненного цикла бинов. Это заставляло разработчика сосредоточиться не на бизнес-логике, а на технической реализации технологических особенностей фреймворка. В EJB 3 бин является POJO и должен реализовать не более одного локального/удаленного интерфейса, который также является POJO.
		2. Введение аннотаций в EJB3, делает жизнь разработчика проще. Больше не нудно определять бины в XML-файле ejb-jar.XML.
		3. EJB3 заменил бины доступа к данным, на спецификацию JPA. Спецификация JPA не привязана к EJB3. Все, что нужно сделать - ввести JPA Entity Manager в контейнер EJB.
		4. EJB3 гораздо более производителен, чем EJB2, так как контейнер не должен выполнять обратные вызовы, такие как ejbActive, ejbStore,…
	
BEANS
	
	Enterprise JavaBeans (также часто употребляется в виде аббревиатуры EJB) — спецификация технологии написания и поддержки серверных компонентов, содержащих бизнес-логику. Является частью Java EE.
	
	Каждый EJB-компонент является набором Java-классов со строго регламентированными правилами именования методов (верно для EJB 2.0, в EJB 3.0 за счет использования аннотаций выбор имён свободный). 
	EJB бывают трёх основных типов:
	
	Entity Bean - это сущности каких то объектов и в EJB оно является хранилищем данных на период жизненного цикла Entity. Работа с entity была описана в спецификации JPA.
		Спецификация JPA определяет стагдарт для:
			1. конфигурации маппинга сущностей приложения и их отображения в таблицах БД;
			2. EntityManager API – позволяет выполнять CRUD (create, read, update, delete) операции над сущностями;
			3. Java Persistence Query Language (JPQL) – для поиска и получения данных приложения
	
		Entity - persistent domain object - основная сущность, которой манипулирует программа (объект бизнес логики).
		Требования JPA к классам бизнес логики:
			1. Entity класс должен быть отмечен аннотацией @Entity или описан в xml файле конфигурации JPA.				
			2. Entity класс должен содержать public или protected конструктор без аргументов. (так же может содержать и конструкторы с аргументами, их наличие не обязательно).
			3. Entity класс должен быть классом верхнего уровня.
			4. Entity класс не может быть Enum или Интерфейсом
			5. Entity класс не может быть final-классом.
			6. Entity класс не может содержать final поля или методы в случае, если он участвует в маппинге.
			7. Если объект Entity будет передаваться по значению как отдельный объект, например через удаленный интерфейс - он должен реализовывать интерфейс Serializable.
			8. Поля Entity класса должны быть private и содержать getter и setter.
			9. Entity класс должен содержать первичный ключ, т.е. атрибут или группу атрибутов, по которым можно однозначено идентифицировать запись этого Entity в базе данных.
	
		Основный аннотации EJB3:
			- @EJB – помечается bean, который мы собираемся использовать.
			- @Stateless – говорит контейнеру, что класс будет stateless session bean. Для него контейнер обеспечит безопасность потоков и менеджмент транзакций.
			- @Local – относится к интерфейсу и говорит, что bean реализующий интерфейс доступен локально.
			- @Remote – относится к интерфейсу и говорит, что bean доступен через RMI (Remote Method Invocation).
			- @Stateful – говорит контейнеру, что класс будет stateful session bean.
			- @Remove – метод, помеченный как Remove говорит контейнеру, что после его исполнения нет больше смысла хранить bean, т.е. его состояние сбрасывается. Это бывает критично для производительности.
			- @Entity – говорит контейнеру, что класс будет сущностью БД.
			- @Table(name=”<name>”) – указывает таблицу для маппинга БД.
			- @Id – указывает уникальный идентификатор сущности который будет ключом в БД.
			- @Column – указывает параметры колонки в БД включая имя колонки в БД.
			- @WebService – говорит, что интерфейс или класс будет представлять web-сервис.
			
		Правила создания session bean
			В качестве session bean может выступать обычный класс Java, но он должен удовлетворять следующим условиям:

			1. Он должен иметь как минимум один метод;
			2. Он не должен быть абстрактным;
			3. Он должен иметь конструктор по-умолчанию;
			4. Методы не должны начинаться с “ejb” (например ejbBean, ejbGoAtHome)
			5. Свойства класса должны быть объявлены примитивами или реализовывать интерфейс Serializable
		
		Жизненный цикл EJB3
			У stateless и MDB бинов существует 2 события жизненного цикла, которые мы можем перехватить. Это создание и удаление бина. Метод, который будет вызываться сразу после создании бина помечается аннотацией @PostConstruct, а перед его удалением – @PreDestroy.

			Stateful бины обладают помимо рассмотреных выше еще 2 событиями:
				1) При активации @PostActivate;
				2) При деактивации @PrePassivate
	Session bean.
		Session beans - сессионные бины - это серверные компоненты,который работают только в случае получения запроса от клиента.
		сессионные бины не доступен напрямую, но он имеет экземпляры, развернутые в контейнере EJB. Таким образом, запрос клиента отправляется на своего рода прокси, который, в свою очередь, делегирует обработку запроса клиента контейнеру EJB, и это зависит от контейнера EJB, выбор правильного экземпляра session bean зависит от контейнера.
		
		Сессионные бины бывают 3 видов:
			1. Stateless session beans - бины без сохранения состояния.
				Представьте, что у вас есть коробка, в которой есть несколько синих ручек с бесконечными чернилами. Если вам нужно записать слово, вы закрываете глаза, берете любую синюю ручку из коробки, чтобы записать слово, записываете, затем возвращаете ручку обратно в коробку. Поскольку в ручке бесконечные чернила, вы не изменили состояние ручки. И по факту любая из тех ручек может записать слово синими чернилами. Принцип работы Stateless beans аналогичен. Контейнер EJB будет иметь пул состояний SB. И согласно внутреннему алгоритму выбора контейнера, клиент может получить любой экземпляр SB без состояния - т.е. просто ручку.

				Аннотация: @Stateless
				Рекоммендуемый способ получения SLSB: Injection.
			2. Stateful Session beans - бины с отслеживанием состояния.
				Бины автоматически сохраняют свое состояние между разными клиентскими вызовами. Типичным примером stateful-бина является корзина в интернет-магазине.
				
				Аннотация: @Stateful
				Рекоммендуемый способ получения SLSB: JNDI поиск.
			3. Singleton beans - бины синглтоны.
				Вместо реализации паттерна Синглтон, можно использовать Singleton beans. Таким образом, даже если у вас было распределенное приложение, каждый модуль будет иметь доступ к одному и тому же экземпляру этого бина. Один элемент является многопоточным . Таким образом, параллельный доступ возможен. Синглтон также может поддерживать состояние, и поэтому мы можем изменять атрибуты экземпляра. Чтобы избежать проблем с параллелизмом, старайтесь управлять им ,например, с помощью ключевого слова synchronized.
				По дефолту инифиализация такого бина будет ленивой. Если нужно инициализировать бин при развертывании приложения - используется аннотация @Startup.
				
				Аннотация: @Singleton
				Рекоммендуемый способ получения SLSB: Injection.
				
	Message Driven Beans — их логика является реакцией на события в системе, позволяет JavaEE обрабатывать события асинхронно.
	
	Список используемых аннотаций EJB